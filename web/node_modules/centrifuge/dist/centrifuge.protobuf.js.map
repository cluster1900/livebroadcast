{
  "version": 3,
  "sources": ["../node_modules/events/events.js", "../node_modules/@protobufjs/aspromise/index.js", "../node_modules/@protobufjs/base64/index.js", "../node_modules/@protobufjs/eventemitter/index.js", "../node_modules/@protobufjs/float/index.js", "../node_modules/@protobufjs/inquire/index.js", "../node_modules/@protobufjs/utf8/index.js", "../node_modules/@protobufjs/pool/index.js", "../node_modules/protobufjs/src/util/longbits.js", "../node_modules/protobufjs/src/util/minimal.js", "../node_modules/protobufjs/src/writer.js", "../node_modules/protobufjs/src/writer_buffer.js", "../node_modules/protobufjs/src/reader.js", "../node_modules/protobufjs/src/reader_buffer.js", "../node_modules/protobufjs/src/rpc/service.js", "../node_modules/protobufjs/src/rpc.js", "../node_modules/protobufjs/src/roots.js", "../node_modules/protobufjs/src/index-minimal.js", "../node_modules/protobufjs/minimal.js", "../src/subscription.ts", "../src/types.ts", "../src/utils.ts", "../src/transport_sockjs.ts", "../src/transport_websocket.ts", "../src/transport_http_stream.ts", "../src/transport_sse.ts", "../src/transport_webtransport.ts", "../src/fossil.ts", "../src/json.ts", "../src/centrifuge.ts", "../src/protobuf.codec.ts", "../src/client_proto.js", "../src/browser.protobuf.ts"],
  "sourcesContent": ["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n", "\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n", "\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n", "\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n", "\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n", "\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n", "\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n", "\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n", "\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n", "\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n", "\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n", "\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n", "\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n", "\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n", "\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n", "\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n", "// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n", "import EventEmitter from 'events';\nimport { Centrifuge, UnauthorizedError } from './centrifuge';\nimport { errorCodes, unsubscribedCodes, subscribingCodes, connectingCodes, subscriptionFlags } from './codes';\nimport {\n  HistoryOptions, HistoryResult, PresenceResult, PresenceStatsResult,\n  PublishResult, State, SubscriptionEvents, SubscriptionOptions,\n  SubscriptionState, SubscriptionTokenContext, TypedEventEmitter,\n  SubscriptionDataContext, FilterNode\n} from './types';\nimport { ttlMilliseconds, backoff } from './utils';\n\n/** Subscription to a channel */\nexport class Subscription extends (EventEmitter as new () => TypedEventEmitter<SubscriptionEvents>) {\n  channel: string;\n  state: SubscriptionState;\n\n  private _centrifuge: Centrifuge;\n  private _promises: Record<number, any>;\n  private _resubscribeTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _refreshTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _getToken: null | ((ctx: SubscriptionTokenContext) => Promise<string>);\n  private _minResubscribeDelay: number;\n  private _maxResubscribeDelay: number;\n  private _recover: boolean;\n  private _offset: number | null;\n  private _epoch: string | null;\n  // @ts-ignore \u2013 this is used by a client in centrifuge.ts.\n  private _id: number;\n  private _resubscribeAttempts: number;\n  private _promiseId: number;\n  private _delta: string;\n  private _delta_negotiated: boolean;\n  private _tagsFilter: FilterNode | null;\n  private _token: string;\n  private _data: any | null;\n  private _getData: null | ((ctx: SubscriptionDataContext) => Promise<any>);\n  private _recoverable: boolean;\n  private _positioned: boolean;\n  private _joinLeave: boolean;\n  // @ts-ignore \u2013 this is used by a client in centrifuge.ts.\n  private _inflight: boolean;\n  private _prevValue: any;\n  private _unsubPromise: any;\n\n  /** Subscription constructor should not be used directly, create subscriptions using Client method. */\n  constructor(centrifuge: Centrifuge, channel: string, options?: Partial<SubscriptionOptions>) {\n    super();\n    this.channel = channel;\n    this.state = SubscriptionState.Unsubscribed;\n    this._centrifuge = centrifuge;\n    this._token = '';\n    this._getToken = null;\n    this._data = null;\n    this._getData = null;\n    this._recover = false;\n    this._offset = null;\n    this._epoch = null;\n    this._id = 0;\n    this._recoverable = false;\n    this._positioned = false;\n    this._joinLeave = false;\n    this._minResubscribeDelay = 500;\n    this._maxResubscribeDelay = 20000;\n    this._resubscribeTimeout = null;\n    this._resubscribeAttempts = 0;\n    this._promises = {};\n    this._promiseId = 0;\n    this._inflight = false;\n    this._refreshTimeout = null;\n    this._delta = '';\n    this._delta_negotiated = false;\n    this._tagsFilter = null;\n    this._prevValue = null;\n    this._unsubPromise = Promise.resolve();\n    this._setOptions(options);\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    if (this._centrifuge._debugEnabled) {\n      this.on('state', (ctx) => {\n        this._debug('subscription state', channel, ctx.oldState, '->', ctx.newState);\n      });\n      this.on('error', (ctx) => {\n        this._debug('subscription error', channel, ctx);\n      });\n    } else {\n      // Avoid unhandled exception in EventEmitter for non-set error handler.\n      this.on('error', function () { Function.prototype(); });\n    }\n  }\n\n  /** ready returns a Promise which resolves upon subscription goes to Subscribed \n   * state and rejects in case of subscription goes to Unsubscribed state. \n   * Optional timeout can be passed.*/\n  ready(timeout?: number): Promise<void> {\n    if (this.state === SubscriptionState.Unsubscribed) {\n      return Promise.reject({ code: errorCodes.subscriptionUnsubscribed, message: this.state });\n    }\n    if (this.state === SubscriptionState.Subscribed) {\n      return Promise.resolve();\n    }\n    return new Promise((res, rej) => {\n      const ctx: any = {\n        resolve: res,\n        reject: rej\n      };\n      if (timeout) {\n        ctx.timeout = setTimeout(function () {\n          rej({ code: errorCodes.timeout, message: 'timeout' });\n        }, timeout);\n      }\n      this._promises[this._nextPromiseId()] = ctx;\n    });\n  }\n\n  /** subscribe to a channel.*/\n  subscribe() {\n    if (this._isSubscribed()) {\n      return;\n    }\n    this._resubscribeAttempts = 0;\n    this._setSubscribing(subscribingCodes.subscribeCalled, 'subscribe called');\n  }\n\n  /** unsubscribe from a channel, keeping position state.*/\n  unsubscribe() {\n    this._unsubPromise = this._setUnsubscribed(unsubscribedCodes.unsubscribeCalled, 'unsubscribe called', true);\n  }\n\n  /** publish data to a channel.*/\n  async publish(data: any): Promise<PublishResult> {\n    await this._methodCall();\n    return this._centrifuge.publish(this.channel, data);\n  }\n\n  /** get online presence for a channel.*/\n  async presence(): Promise<PresenceResult> {\n    await this._methodCall();\n    return this._centrifuge.presence(this.channel);\n  }\n\n  /** presence stats for a channel (num clients and unique users).*/\n  async presenceStats(): Promise<PresenceStatsResult> {\n    await this._methodCall();\n    return this._centrifuge.presenceStats(this.channel);\n  }\n\n  /** history for a channel. By default it does not return publications (only current\n   *  StreamPosition data) \u2013 provide an explicit limit > 0 to load publications.*/\n  async history(opts: HistoryOptions): Promise<HistoryResult> {\n    await this._methodCall();\n    return this._centrifuge.history(this.channel, opts);\n  }\n\n  /**\n   * Sets server-side tags filter for the subscription.\n   * This only applies on the next subscription attempt, not the current one.\n   * Cannot be used together with delta option.\n   *\n   * @param tagsFilter - Filter configuration object or null to remove filter\n   * @throws {Error} If both delta and tagsFilter are configured\n   *\n   * @example\n   * ```typescript\n   * // Simple equality filter\n   * sub.setTagsFilter({\n   *   key: 'ticker',\n   *   cmp: 'eq',\n   *   val: 'BTC'\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Complex filter with logical operators\n   * sub.setTagsFilter({\n   *   op: 'and',\n   *   nodes: [\n   *     { key: 'ticker', cmp: 'eq', val: 'BTC' },\n   *     { key: 'price', cmp: 'gt', val: '50000' }\n   *   ]\n   * });\n   * ```\n   *\n   * @example\n   * ```typescript\n   * // Filter with IN operator\n   * sub.setTagsFilter({\n   *   key: 'ticker',\n   *   cmp: 'in',\n   *   vals: ['BTC', 'ETH', 'SOL']\n   * });\n   * ```\n   */\n  setTagsFilter(tagsFilter: FilterNode | null): void {\n    if (tagsFilter && this._delta) {\n      throw new Error('cannot use delta and tagsFilter together');\n    }\n    this._tagsFilter = tagsFilter;\n  }\n\n  /** setData allows setting subscription data. This only applied on the next subscription attempt,\n   * Note that if getData callback is configured, it will override this value during resubscriptions. */\n  setData(data: any) {\n    this._data = data;\n  }\n\n  private _methodCall(): Promise<void> {\n    if (this._isSubscribed()) {\n      return Promise.resolve();\n    }\n\n    if (this._isUnsubscribed()) {\n      return Promise.reject({\n        code: errorCodes.subscriptionUnsubscribed,\n        message: this.state\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      const timeoutDuration = this._centrifuge._config.timeout;\n\n      const timeout = setTimeout(() => {\n        reject({ code: errorCodes.timeout, message: 'timeout' });\n      }, timeoutDuration);\n\n      this._promises[this._nextPromiseId()] = {\n        timeout,\n        resolve,\n        reject\n      };\n    });\n  }\n\n  private _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  private _needRecover() {\n    return this._recover === true;\n  }\n\n  private _isUnsubscribed() {\n    return this.state === SubscriptionState.Unsubscribed;\n  }\n\n  private _isSubscribing() {\n    return this.state === SubscriptionState.Subscribing;\n  }\n\n  private _isSubscribed() {\n    return this.state === SubscriptionState.Subscribed;\n  }\n\n  private _setState(newState: SubscriptionState) {\n    if (this.state !== newState) {\n      const oldState = this.state;\n      this.state = newState;\n      this.emit('state', { newState, oldState, channel: this.channel });\n      return true;\n    }\n    return false;\n  }\n\n  private _usesToken(): boolean {\n    return this._token !== '' || this._getToken !== null;\n  }\n\n  private _clearSubscribingState() {\n    this._resubscribeAttempts = 0;\n    this._clearResubscribeTimeout();\n  }\n\n  private _clearSubscribedState() {\n    this._clearRefreshTimeout();\n  }\n\n  private _setSubscribed(result: any) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    this._clearSubscribingState();\n\n    if (result.id) {\n      this._id = result.id;\n    }\n\n    if (result.recoverable) {\n      this._recover = true;\n      this._offset = result.offset || 0;\n      this._epoch = result.epoch || '';\n    }\n    if (result.delta) {\n      this._delta_negotiated = true;\n    } else {\n      this._delta_negotiated = false;\n    }\n\n    this._setState(SubscriptionState.Subscribed);\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const ctx = this._centrifuge._getSubscribeContext(this.channel, result);\n    this.emit('subscribed', ctx);\n    this._resolvePromises();\n\n    const pubs = result.publications;\n    if (pubs && pubs.length > 0) {\n      for (const i in pubs) {\n        if (!pubs.hasOwnProperty(i)) {\n          continue;\n        }\n        this._handlePublication(pubs[i]);\n      }\n    }\n\n    if (result.expires === true) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private async _setSubscribing(code: number, reason: string) {\n    if (this._isSubscribing()) {\n      return;\n    }\n    if (this._isSubscribed()) {\n      this._clearSubscribedState();\n    }\n    if (this._setState(SubscriptionState.Subscribing)) {\n      this.emit('subscribing', { channel: this.channel, code: code, reason: reason });\n    }\n    // @ts-ignore \u2013 for performance reasons only await _unsubPromise for emulution case where it's required.\n    if (this._centrifuge._transport && this._centrifuge._transport.emulation()) {\n      await this._unsubPromise;\n    }\n    if (!this._isSubscribing()) {\n      return;\n    }\n    this._subscribe();\n  }\n\n  private _subscribe(): any {\n    this._debug('subscribing on', this.channel);\n\n    if (!this._isTransportOpen()) {\n      this._debug('delay subscribe on', this.channel, 'till connected');\n      return null;\n    }\n\n    if (this._inflight) {\n      return null;\n    }\n    this._inflight = true;\n\n    if (this._canSubscribeWithoutGettingToken()) {\n      return this._subscribeWithoutToken();\n    }\n\n    this._getSubscriptionToken()\n      .then(token => this._handleTokenResponse(token))\n      .catch(e => this._handleTokenError(e));\n\n    return null;\n  }\n\n  private _isTransportOpen(): boolean {\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    return this._centrifuge._transportIsOpen;\n  }\n\n  private _canSubscribeWithoutGettingToken(): boolean {\n    return !this._usesToken() || !!this._token;\n  }\n\n  private _subscribeWithoutToken(): any {\n    if (this._getData) {\n      this._getDataAndSubscribe(this._token);\n      return null;\n    } else {\n      return this._sendSubscribe(this._token);\n    }\n  }\n\n  private _getDataAndSubscribe(token: string): void {\n    if (!this._getData) {\n      this._inflight = false;\n      return;\n    }\n\n    this._getData({ channel: this.channel })\n      .then(data => {\n        if (!this._isSubscribing()) {\n          this._inflight = false;\n          return;\n        }\n        this._data = data;\n        this._sendSubscribe(token);\n      })\n      .catch(e => this._handleGetDataError(e));\n  }\n\n  private _handleGetDataError(error: any): void {\n    if (!this._isSubscribing()) {\n      this._inflight = false;\n      return;\n    }\n\n    if (error instanceof UnauthorizedError) {\n      this._inflight = false;\n      this._failUnauthorized();\n      return;\n    }\n\n    this.emit('error', {\n      type: 'subscribeData',\n      channel: this.channel,\n      error: {\n        code: errorCodes.badConfiguration,\n        message: error?.toString() || ''\n      }\n    });\n\n    this._inflight = false;\n    this._scheduleResubscribe();\n  }\n\n  private _handleTokenResponse(token: string | null): void {\n    if (!this._isSubscribing()) {\n      this._inflight = false;\n      return;\n    }\n\n    if (!token) {\n      this._inflight = false;\n      this._failUnauthorized();\n      return;\n    }\n\n    this._token = token;\n\n    if (this._getData) {\n      this._getDataAndSubscribe(token);\n    } else {\n      this._sendSubscribe(token);\n    }\n  }\n\n  private _handleTokenError(error: any): void {\n    if (!this._isSubscribing()) {\n      this._inflight = false;\n      return;\n    }\n\n    if (error instanceof UnauthorizedError) {\n      this._inflight = false;\n      this._failUnauthorized();\n      return;\n    }\n\n    this.emit('error', {\n      type: 'subscribeToken',\n      channel: this.channel,\n      error: {\n        code: errorCodes.subscriptionSubscribeToken,\n        message: error?.toString() || ''\n      }\n    });\n\n    this._inflight = false;\n    this._scheduleResubscribe();\n  }\n\n  private _sendSubscribe(token: string): any {\n    if (!this._isTransportOpen()) {\n      this._inflight = false;\n      return null;\n    }\n\n    const cmd = this._buildSubscribeCommand(token);\n\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    this._centrifuge._call(cmd).then(resolveCtx => {\n      this._inflight = false;\n      const result = resolveCtx.reply.subscribe;\n      this._handleSubscribeResponse(result);\n      if (resolveCtx.next) {\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      this._inflight = false;\n      this._handleSubscribeError(rejectCtx.error);\n\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n\n    return cmd;\n  }\n\n  private _buildSubscribeCommand(token: string): any {\n    const req: any = { channel: this.channel };\n\n    if (token) req.token = token;\n    if (this._data) req.data = this._data;\n    if (this._positioned) req.positioned = true;\n    if (this._recoverable) req.recoverable = true;\n    if (this._joinLeave) req.join_leave = true;\n    req.flag = subscriptionFlags.channelCompaction;\n\n    if (this._needRecover()) {\n      req.recover = true;\n      const offset = this._getOffset();\n      if (offset) req.offset = offset;\n      const epoch = this._getEpoch();\n      if (epoch) req.epoch = epoch;\n    }\n\n    if (this._delta) req.delta = this._delta;\n    if (this._tagsFilter) req.tf = this._tagsFilter;\n\n    return { subscribe: req };\n  }\n\n  private _debug(...args: any[]): void {\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    this._centrifuge._debug(...args);\n  }\n\n  private _handleSubscribeError(error) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    if (error.code === errorCodes.timeout) {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      this._centrifuge._disconnect(connectingCodes.subscribeTimeout, 'subscribe timeout', true);\n      return;\n    }\n    this._subscribeError(error);\n  }\n\n  private _handleSubscribeResponse(result) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    this._setSubscribed(result);\n  }\n\n  private _setUnsubscribed(code, reason, sendUnsubscribe): Promise<void> {\n    if (this._isUnsubscribed()) {\n      return Promise.resolve();\n    }\n    let promise = Promise.resolve();\n    if (this._isSubscribed()) {\n      if (sendUnsubscribe) {\n        // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n        promise = this._centrifuge._unsubscribe(this);\n      }\n      this._clearSubscribedState();\n    } else if (this._isSubscribing()) {\n      if (this._inflight && sendUnsubscribe) {\n        // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n        promise = this._centrifuge._unsubscribe(this);\n      }\n      this._clearSubscribingState();\n    }\n    this._inflight = false;\n    if (this._setState(SubscriptionState.Unsubscribed)) {\n      this.emit('unsubscribed', { channel: this.channel, code: code, reason: reason });\n    }\n    this._rejectPromises({ code: errorCodes.subscriptionUnsubscribed, message: this.state });\n    return promise;\n  }\n\n  private _handlePublication(pub: any) {\n    if (this._delta && this._delta_negotiated) {\n      // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n      const { newData, newPrevValue } = this._centrifuge._codec.applyDeltaIfNeeded(pub, this._prevValue)\n      pub.data = newData;\n      this._prevValue = newPrevValue;\n    }\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const ctx = this._centrifuge._getPublicationContext(this.channel, pub);\n    this.emit('publication', ctx);\n    if (pub.offset) {\n      this._offset = pub.offset;\n    }\n  }\n\n  protected _handleJoin(join: any) {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const info = this._centrifuge._getJoinLeaveContext(join.info)\n    this.emit('join', { channel: this.channel, info: info });\n  }\n\n  protected _handleLeave(leave: any) {\n    // @ts-ignore \u2013 we are hiding some methods from public API autocompletion.\n    const info = this._centrifuge._getJoinLeaveContext(leave.info)\n    this.emit('leave', { channel: this.channel, info: info });\n  }\n\n  private _resolvePromises() {\n    for (const id in this._promises) {\n      if (!this._promises.hasOwnProperty(id)) {\n        continue;\n      }\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  }\n\n  private _rejectPromises(err: any) {\n    for (const id in this._promises) {\n      if (!this._promises.hasOwnProperty(id)) {\n        continue;\n      }\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  }\n\n  private _scheduleResubscribe() {\n    if (!this._isSubscribing()) {\n      this._debug('not in subscribing state, skip resubscribe scheduling', this.channel);\n      return;\n    }\n    const self = this;\n    const delay = this._getResubscribeDelay();\n    this._resubscribeTimeout = setTimeout(function () {\n      if (self._isSubscribing()) {\n        self._subscribe();\n      }\n    }, delay);\n    this._debug('resubscribe scheduled after ' + delay, this.channel);\n  }\n\n  private _subscribeError(err: any) {\n    if (!this._isSubscribing()) {\n      return;\n    }\n    if (err.code < 100 || err.code === 109 || err.temporary === true) {\n      if (err.code === 109) { // Token expired error.\n        this._token = '';\n      }\n      const errContext = {\n        channel: this.channel,\n        type: 'subscribe',\n        error: err\n      };\n      if (this._centrifuge.state === State.Connected) {\n        this.emit('error', errContext);\n      }\n      this._scheduleResubscribe();\n    } else {\n      this._setUnsubscribed(err.code, err.message, false);\n    }\n  }\n\n  private _getResubscribeDelay() {\n    const delay = backoff(this._resubscribeAttempts, this._minResubscribeDelay, this._maxResubscribeDelay);\n    this._resubscribeAttempts++;\n    return delay;\n  }\n\n  private _setOptions(options: Partial<SubscriptionOptions> | undefined) {\n    if (!options) {\n      return;\n    }\n    if (options.since) {\n      this._offset = options.since.offset || 0;\n      this._epoch = options.since.epoch || '';\n      this._recover = true;\n    }\n    if (options.data) {\n      this._data = options.data;\n    }\n    if (options.getData) {\n      this._getData = options.getData;\n    }\n    if (options.minResubscribeDelay !== undefined) {\n      this._minResubscribeDelay = options.minResubscribeDelay;\n    }\n    if (options.maxResubscribeDelay !== undefined) {\n      this._maxResubscribeDelay = options.maxResubscribeDelay;\n    }\n    if (options.token) {\n      this._token = options.token;\n    }\n    if (options.getToken) {\n      this._getToken = options.getToken;\n    }\n    if (options.positioned === true) {\n      this._positioned = true;\n    }\n    if (options.recoverable === true) {\n      this._recoverable = true;\n    }\n    if (options.joinLeave === true) {\n      this._joinLeave = true;\n    }\n    if (options.delta) {\n      if (options.delta !== 'fossil') {\n        throw new Error('unsupported delta format');\n      }\n      this._delta = options.delta;\n    }\n    if (options.tagsFilter) {\n      this._tagsFilter = options.tagsFilter;\n    }\n    if (this._tagsFilter && this._delta) {\n      throw new Error('cannot use delta and tagsFilter together');\n    }\n  }\n\n  private _getOffset() {\n    const offset = this._offset;\n    if (offset !== null) {\n      return offset;\n    }\n    return 0;\n  }\n\n  private _getEpoch() {\n    const epoch = this._epoch;\n    if (epoch !== null) {\n      return epoch;\n    }\n    return '';\n  }\n\n  private _clearRefreshTimeout() {\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n  }\n\n  private _clearResubscribeTimeout() {\n    if (this._resubscribeTimeout !== null) {\n      clearTimeout(this._resubscribeTimeout);\n      this._resubscribeTimeout = null;\n    }\n  }\n\n  private _getSubscriptionToken() {\n    this._debug('get subscription token for channel', this.channel);\n    const ctx = {\n      channel: this.channel\n    };\n    const getToken = this._getToken;\n    if (getToken === null) {\n      this.emit('error', {\n        type: 'configuration',\n        channel: this.channel,\n        error: {\n          code: errorCodes.badConfiguration,\n          message: 'provide a function to get channel subscription token'\n        }\n      });\n      return Promise.reject(new UnauthorizedError(''));\n    }\n    return getToken(ctx);\n  }\n\n  private _refresh() {\n    this._clearRefreshTimeout();\n    const self = this;\n    this._getSubscriptionToken().then(function (token) {\n      if (!self._isSubscribed()) {\n        return;\n      }\n      if (!token) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      const req = {\n        channel: self.channel,\n        token: token\n      };\n      const msg = {\n        'sub_refresh': req\n      };\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      self._centrifuge._call(msg).then(resolveCtx => {\n        const result = resolveCtx.reply.sub_refresh;\n        self._refreshResponse(result);\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        self._refreshError(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }).catch(function (e) {\n      if (e instanceof UnauthorizedError) {\n        self._failUnauthorized();\n        return;\n      }\n      self.emit('error', {\n        type: 'refreshToken',\n        channel: self.channel,\n        error: {\n          code: errorCodes.subscriptionRefreshToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n    });\n  }\n\n  private _refreshResponse(result: any) {\n    if (!this._isSubscribed()) {\n      return;\n    }\n    this._debug('subscription token refreshed, channel', this.channel);\n    this._clearRefreshTimeout();\n    if (result.expires === true) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private _refreshError(err: any) {\n    if (!this._isSubscribed()) {\n      return;\n    }\n    if (err.code < 100 || err.temporary === true) {\n      this.emit('error', {\n        type: 'refresh',\n        channel: this.channel,\n        error: err\n      });\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n    } else {\n      this._setUnsubscribed(err.code, err.message, true);\n    }\n  }\n\n  private _getRefreshRetryDelay() {\n    return backoff(0, 10000, 20000);\n  }\n\n  private _failUnauthorized() {\n    this._setUnsubscribed(unsubscribedCodes.unauthorized, 'unauthorized', true);\n  }\n}", "/** EventMap */\nexport type EventMap = {\n  [key: string]: (...args: any[]) => void\n}\n\n/** Typed event emitter. */\nexport interface TypedEventEmitter<Events extends EventMap> {\n  addListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  on<E extends keyof Events>(event: E, listener: Events[E]): this\n  once<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependOnceListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  off<E extends keyof Events>(event: E, listener: Events[E]): this\n  removeAllListeners<E extends keyof Events>(event?: E): this\n  removeListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  emit<E extends keyof Events>(event: E, ...args: Parameters<Events[E]>): boolean\n  rawListeners<E extends keyof Events>(event: E): Events[E][]\n  listeners<E extends keyof Events>(event: E): Events[E][]\n}\n\n/** Client events which can be emitted. */\nexport type ClientEvents = {\n  /** called when client state changes */\n  state: (ctx: StateContext) => void;\n  /** called when client goes to connecting state */\n  connecting: (ctx: ConnectingContext) => void;\n  /** called when client goes to connected state */\n  connected: (ctx: ConnectedContext) => void;\n  /** called when client goes to disconnected state */\n  disconnected: (ctx: DisconnectedContext) => void;\n\n  // Async message coming from a server.\n  message: (ctx: MessageContext) => void;\n  // Listen to errors happening internally. \n  error: (ctx: ErrorContext) => void;\n\n  // Listen for server-side subscription events.\n  subscribed: (ctx: ServerSubscribedContext) => void;\n  subscribing: (ctx: ServerSubscribingContext) => void;\n  unsubscribed: (ctx: ServerUnsubscribedContext) => void;\n  publication: (ctx: ServerPublicationContext) => void;\n  join: (ctx: ServerJoinContext) => void;\n  leave: (ctx: ServerLeaveContext) => void;\n}\n\n/** State of client. */\nexport enum State {\n  Disconnected = \"disconnected\",\n  Connecting = \"connecting\",\n  Connected = \"connected\"\n}\n\n/** Events of Subscription. */\nexport type SubscriptionEvents = {\n  /** called when subscription state changes */\n  state: (ctx: SubscriptionStateContext) => void;\n  /** called when subscription state goes to subscribing */\n  subscribing: (ctx: SubscribingContext) => void;\n  /** called when subscription state goes to subscribed */\n  subscribed: (ctx: SubscribedContext) => void;\n  /** called when subscription state goes to unsubscribed */\n  unsubscribed: (ctx: UnsubscribedContext) => void;\n\n  /** called when publication from channel received */\n  publication: (ctx: PublicationContext) => void;\n  /** called when join event from channel received */\n  join: (ctx: JoinContext) => void;\n  /** called when leave event from channel received */\n  leave: (ctx: LeaveContext) => void;\n\n  /** listen to subscription errors happening internally */\n  error: (ctx: SubscriptionErrorContext) => void;\n}\n\n/** State of Subscription */\nexport enum SubscriptionState {\n  Unsubscribed = \"unsubscribed\",\n  Subscribing = \"subscribing\",\n  Subscribed = \"subscribed\"\n}\n\nexport type TransportName = 'websocket' | 'http_stream' | 'sse' | 'sockjs' | 'webtransport';\n\n/** TransportEndpoint allows configuring transport when using fallback mode */\nexport interface TransportEndpoint {\n  /** transport to use */\n  transport: TransportName;\n  /** endpoint for a selected transport type */\n  endpoint: string;\n}\n\n/** Options for Centrifuge client. */\nexport interface Options {\n  // provide header emulation, these headers are sent with first protocol message\n  // the backend can process those in a customized manner. In case of Centrifugo\n  // these headers are then used like real HTTP headers sent from the client.\n  // Requires Centrifugo v6.\n  headers: {[key: string]: string};\n  /** allows enabling debug mode */\n  debug: boolean;\n  /** allows setting initial connection token (JWT) */\n  token: string;\n  /** allows setting function to get/refresh connection token,\n   * this will only be called when new token needed, not on every reconnect. */\n  getToken: null | ((ctx: ConnectionTokenContext) => Promise<string>);\n  /** data to send to a server with connect command */\n  data: any | null;\n  /** allows setting function to get/renew connection data (called upon reconnects).\n   * In many cases you may prefer using setData method of Centrifuge Client instead. */\n  getData: null | (() => Promise<any>);\n  /** name of client - it's not a unique name for each connection, it's something to identify\n   * where the client connected from */\n  name: string;\n  /** version of client */\n  version: string;\n  /** minimum delay between reconnect attempts in milliseconds */\n  minReconnectDelay: number;\n  /** maximum delay between reconnect attempts in milliseconds */\n  maxReconnectDelay: number;\n  /** timeout for operations in milliseconds */\n  timeout: number;\n  /** maximum delay of server pings to detect broken connection in milliseconds */\n  maxServerPingDelay: number;\n  /** provide custom WebSocket constructor, useful for NodeJS env where WebSocket is not\n   * available globally */\n  websocket: any | null;\n  /** provide shim for fetch implementation */\n  fetch: any | null;\n  /** provide shim for ReadableStream */\n  readableStream: any | null;\n  /** provide shim for EventSource object */\n  eventsource: any | null;\n  /** provide shim for SockJS object */\n  sockjs: any | null;\n  /** allows modifying options passed to SockJS constructor */\n  sockjsOptions: SockjsOptions;\n  /** emulation endpoint to use */\n  emulationEndpoint: string;\n  /** EventTarget for network online/offline events. In a browser environment,\n   * Centrifuge uses global window online/offline events automatically\n   * by default. */\n  networkEventTarget: EventTarget | null;\n}\n\nexport interface SockjsOptions {\n  transports?: string[];\n  timeout?: number;\n}\n\nexport interface StateContext {\n  newState: State;\n  oldState: State;\n}\n\nexport interface ConnectedContext {\n  client: string;\n  transport: string;\n  data?: any;\n}\n\nexport interface ErrorContext {\n  type: string;\n  error: Error;\n  transport?: string;\n}\n\nexport interface Error {\n  code: number;\n  message: string;\n}\n\nexport interface ConnectingContext {\n  code: number;\n  reason: string;\n}\n\nexport interface DisconnectedContext {\n  code: number;\n  reason: string;\n}\n\nexport interface MessageContext {\n  data: any;\n}\n\nexport interface PublicationContext {\n  // channel from which publication was received.\n  channel: string;\n  // data contains publication payload.\n  data: any;\n  // info is an optional ClientInfo object. It's appended to a publication only if the publication was\n  // sent using the client SDK's publish method. If the publication was sent over the server publish API,\n  // this info object is missing as we don't have the publisher client context in that case.\n  info?: ClientInfo;\n  // offset may be set for channels where the history Centrifugo feature is enabled. In this case, it's an\n  // incremental number assigned to the publication by the server broker (upon adding to the history stream).   \n  offset?: number;\n  // tags is an extra key-value map attached to a publication. Tags may be set when calling the server publish API. \n  tags?: Record<string, string>;\n}\n\nexport interface ClientInfo {\n  // client is a globally unique identifier that the server allocates for every connection.\n  client: string;\n  // user contains the ID of the authenticated user. An empty user means an anonymous user. One user can have\n  // many client connections.\n  user: string;\n  // connInfo is optional information attached to connection (during connection authentication).\n  connInfo?: any;\n  // chanInfo is optional information attached to subscription (during subscription authorization).\n  chanInfo?: any;\n}\n\nexport interface JoinContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface LeaveContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface SubscriptionStateContext {\n  channel: string;\n  newState: SubscriptionState;\n  oldState: SubscriptionState;\n}\n\nexport interface ServerSubscribedContext {\n  /** channel of Subscription. */\n  channel: string;\n  /** subscription is recoverable \u2013 i.e. can automatically recover missed messages */\n  recoverable: boolean;\n  /** subscription is positioned \u2013 i.e. server tracks message loss on the way from PUB/SUB broker */\n  positioned: boolean;\n  /** streamPosition is set when Subscription is recoverable or positioned. */\n  streamPosition?: StreamPosition;\n  /** wasRecovering is true when recovery was used in the subscribe request. */\n  wasRecovering: boolean;\n  /** whether or not missed publications were successfully recovered.  */\n  recovered: boolean;\n  /** whether or not a successfully recovered subscription has received missed publications.\n  Warning: must be used for metrics/logs purposes only.\n  Recovered publications are processed after the 'subscribed' event. **/\n  hasRecoveredPublications: boolean;\n  /** custom data for Subscription returned from server. */\n  data?: any;\n}\n\nexport interface SubscribedContext {\n  /** channel of Subscription. */\n  channel: string;\n  /** subscription is recoverable \u2013 i.e. can automatically recover missed messages */\n  recoverable: boolean;\n  /** subscription is positioned \u2013 i.e. server tracks message loss on the way from PUB/SUB broker */\n  positioned: boolean;\n  /** streamPosition is set when Subscription is recoverable or positioned. */\n  streamPosition?: StreamPosition;\n  /** wasRecovering is true when recovery was used in the subscribe request. */\n  wasRecovering: boolean;\n  /** whether or not missed publications were successfully recovered.  */\n  recovered: boolean;\n  /** whether or not a successfully recovered subscription has received missed publications.\n  Warning: must be used for metrics/logs purposes only.\n  Recovered publications are processed after the 'subscribed' event. **/\n  hasRecoveredPublications: boolean;\n  /** custom data for Subscription returned from server. */\n  data?: any;\n}\n\nexport interface SubscriptionErrorContext {\n  channel: string;\n  type: string;\n  error: Error;\n}\n\nexport interface UnsubscribedContext {\n  channel: string;\n  code: number;\n  reason: string;\n}\n\nexport interface ServerPublicationContext {\n  // channel from which publication was received.\n  channel: string;\n  // data contains publication payload.\n  data: any;\n  // info is an optional ClientInfo object. It's appended to a publication only if the publication was\n  // sent using the client SDK's publish method. If the publication was sent over the server publish API,\n  // this info object is missing as we don't have the publisher client context in that case.\n  info?: ClientInfo;\n  // offset may be set for channels where the history Centrifugo feature is enabled. In this case, it's an\n  // incremental number assigned to the publication by the server broker (upon adding to the history stream).   \n  offset?: number;\n  // tags is an extra key-value map attached to a publication. Tags may be set when calling the server publish API. \n  tags?: Record<string, string>;\n}\n\nexport interface ServerJoinContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface ServerLeaveContext {\n  channel: string;\n  info: ClientInfo;\n}\n\nexport interface ServerUnsubscribedContext {\n  channel: string;\n}\n\nexport interface SubscribingContext {\n  channel: string;\n  code: number;\n  reason: string;\n}\n\nexport interface ServerSubscribingContext {\n  channel: string;\n}\n\nexport interface ConnectionTokenContext {\n}\n\nexport interface SubscriptionTokenContext {\n  channel: string;\n}\n\nexport interface SubscriptionDataContext {\n  channel: string;\n}\n\nexport interface PublishResult {\n}\n\nexport interface RpcResult {\n  data: any;\n}\n\nexport interface PresenceResult {\n  clients: Record<string, ClientInfo>;\n}\n\nexport interface PresenceStatsResult {\n  numClients: number;\n  numUsers: number;\n}\n\nexport interface HistoryResult {\n  publications: PublicationContext[];\n  offset: number;\n  epoch: string;\n}\n\nexport interface HistoryOptions {\n  limit?: number;\n  since?: StreamPosition;\n  reverse?: boolean;\n}\n\n/**\n * Comparison operators for leaf filter nodes.\n * Used when FilterNode.op is empty (leaf node).\n */\nexport type FilterComparisonOperator =\n  | 'eq'   // equal\n  | 'neq'  // not equal\n  | 'in'   // value is in vals array\n  | 'nin'  // value is not in vals array\n  | 'ex'   // key exists in tags\n  | 'nex'  // key does not exist in tags\n  | 'sw'   // string starts with val\n  | 'ew'   // string ends with val\n  | 'ct'   // string contains val\n  | 'lt'   // numeric less than val\n  | 'lte'  // numeric less than or equal to val\n  | 'gt'   // numeric greater than val\n  | 'gte'; // numeric greater than or equal to val\n\n/**\n * Logical operators for complex filter nodes.\n * Used in FilterNode.op for combining multiple conditions.\n */\nexport type FilterLogicalOperator = 'and' | 'or' | 'not';\n\n/**\n * FilterNode represents a node in a filter expression tree used for server-side\n * publication filtering. It can be either:\n * - A leaf node (comparison) when op is empty\n * - A logical operation node (and/or/not) when op is set\n *\n * @example\n * // Simple equality filter\n * const filter: FilterNode = {\n *   key: 'ticker',\n *   cmp: 'eq',\n *   val: 'BTC'\n * };\n *\n * @example\n * // Filter with multiple conditions\n * const filter: FilterNode = {\n *   op: 'and',\n *   nodes: [\n *     { key: 'ticker', cmp: 'eq', val: 'BTC' },\n *     { key: 'price', cmp: 'gt', val: '50000' }\n *   ]\n * };\n *\n * @example\n * // Filter with IN operator\n * const filter: FilterNode = {\n *   key: 'ticker',\n *   cmp: 'in',\n *   vals: ['BTC', 'ETH', 'SOL']\n * };\n */\nexport interface FilterNode {\n  /**\n   * Operation type for this node:\n   * - \"\" (empty string or undefined) \u2192 leaf node (comparison)\n   * - \"and\" \u2192 logical AND of child nodes\n   * - \"or\" \u2192 logical OR of child nodes\n   * - \"not\" \u2192 logical NOT of a single child node\n   */\n  op?: FilterLogicalOperator;\n\n  /**\n   * Key for comparison (only valid for leaf nodes).\n   * The tag key to compare against.\n   */\n  key?: string;\n\n  /**\n   * Comparison operator for leaf nodes.\n   * Only meaningful if op is empty (leaf node).\n   */\n  cmp?: FilterComparisonOperator;\n\n  /**\n   * Single value used in most comparisons.\n   * Used with operators: eq, neq, sw, ew, ct, lt, lte, gt, gte.\n   */\n  val?: string;\n\n  /**\n   * Multiple values used for set comparisons.\n   * Used with operators: in, nin.\n   */\n  vals?: string[];\n\n  /**\n   * Child nodes for logical operations.\n   * Used when op is \"and\", \"or\", or \"not\".\n   */\n  nodes?: FilterNode[];\n}\n\n/** SubscriptionOptions can customize Subscription. */\nexport interface SubscriptionOptions {\n  /** allows setting initial subscription token (JWT) */\n  token: string;\n  /** allows setting function to get/refresh subscription token,\n   * this will only be called when new token needed, not on every resubscribe. */\n  getToken: null | ((ctx: SubscriptionTokenContext) => Promise<string>);\n  /** data to send to a server with subscribe command */\n  data: any | null;\n  /** allows setting function to get/renew subscription data (during resubscriptions).\n   * In many cases you may prefer using setData method of Subscription instead. */\n  getData: null | ((ctx: SubscriptionDataContext) => Promise<any>);\n  /** force recovery on first subscribe from a provided StreamPosition. */\n  since: Partial<StreamPosition> | null;\n  /** min delay between resubscribe attempts. */\n  minResubscribeDelay: number;\n  /** max delay between resubscribe attempts. */\n  maxResubscribeDelay: number;\n  /** ask server to make subscription positioned. */\n  positioned: boolean;\n  /** ask server to make subscription recoverable. */\n  recoverable: boolean;\n  /** ask server to send join/leave messages. */\n  joinLeave: boolean;\n  /** delta format to be used. Delta usage must be allowed on the server side. */\n  delta: 'fossil';\n  /** server-side tagsFilter to apply for publications in channel. Tags filter support must be allowed on the server side. */\n  tagsFilter: FilterNode | null;\n}\n\n/** Stream position describes the position of a publication inside a stream.  */\nexport interface StreamPosition {\n  offset: number;\n  epoch: string;\n}\n", "/** @internal */\nexport function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n}\n\n/** @internal */\nexport function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n}\n\n/** @internal */\nexport function log(level: string, args) {\n  if (globalThis.console) {\n    const logger = globalThis.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(globalThis.console, args);\n    }\n  }\n}\n\nfunction randomInt(min: number, max: number) { // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/** @internal */\nexport function backoff(step: number, min: number, max: number) {\n  // Full jitter technique, see:\n  // https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n  if (step > 31) { step = 31; }\n  const interval = randomInt(0, Math.min(max, min * Math.pow(2, step)));\n  return Math.min(max, min + interval);\n}\n\n/** @internal */\nexport function errorExists(data: any) {\n  return 'error' in data && data.error !== null;\n}\n\n/** @internal */\nexport function ttlMilliseconds(ttl: number) {\n  // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n  return Math.min(ttl * 1000, 2147483647);\n}\n", "/** @internal */\nexport class SockjsTransport {\n  endpoint: string;\n  options: any;\n  _transport: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n  }\n\n  name() {\n    return 'sockjs';\n  }\n\n  subName() {\n    return 'sockjs-' + this._transport.transport;\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.sockjs !== null;\n  }\n\n  initialize(_protocol: 'json', callbacks: any) {\n    this._transport = new this.options.sockjs(this.endpoint, null, this.options.sockjsOptions);\n\n    this._transport.onopen = () => {\n      callbacks.onOpen();\n    };\n\n    this._transport.onerror = e => {\n      callbacks.onError(e);\n    };\n\n    this._transport.onclose = closeEvent => {\n      callbacks.onClose(closeEvent);\n    };\n\n    this._transport.onmessage = event => {\n      callbacks.onMessage(event.data);\n    };\n  }\n\n  close() {\n    this._transport.close();\n  }\n\n  send(data: any) {\n    this._transport.send(data);\n  }\n}\n", "/** @internal */\nexport class WebsocketTransport {\n  private _transport: any;\n  private endpoint: string;\n  private options: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n  }\n\n  name() {\n    return 'websocket';\n  }\n\n  subName() {\n    return 'websocket';\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.websocket !== undefined && this.options.websocket !== null;\n  }\n\n  initialize(protocol: string, callbacks: any) {\n    let subProtocol = '';\n    if (protocol === 'protobuf') {\n      subProtocol = 'centrifuge-protobuf';\n    }\n    if (subProtocol !== '') {\n      this._transport = new this.options.websocket(this.endpoint, subProtocol);\n    } else {\n      this._transport = new this.options.websocket(this.endpoint);\n    }\n    if (protocol === 'protobuf') {\n      this._transport.binaryType = 'arraybuffer';\n    }\n\n    this._transport.onopen = () => {\n      callbacks.onOpen();\n    };\n\n    this._transport.onerror = e => {\n      callbacks.onError(e);\n    };\n\n    this._transport.onclose = closeEvent => {\n      callbacks.onClose(closeEvent);\n    };\n\n    this._transport.onmessage = event => {\n      callbacks.onMessage(event.data);\n    };\n  }\n\n  close() {\n    this._transport.close();\n  }\n\n  send(data: any) {\n    this._transport.send(data);\n  }\n}\n", "/** @internal */\nexport class HttpStreamTransport {\n  endpoint: string;\n  options: any;\n  _abortController: any | null;\n  _utf8decoder: TextDecoder;\n  _protocol: string;\n\n  constructor(endpoint, options) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._abortController = null;\n    this._utf8decoder = new TextDecoder();\n    this._protocol = 'json';\n  }\n\n  name() {\n    return 'http_stream';\n  }\n\n  subName() {\n    return 'http_stream';\n  }\n\n  emulation() {\n    return true;\n  }\n\n  _handleErrors(response: any) {\n    if (!response.ok) throw new Error(response.status);\n    return response;\n  }\n\n  _fetchEventTarget(self, endpoint: string, options: object) {\n    const eventTarget = new EventTarget();\n    // fetch with connection timeout maybe? https://github.com/github/fetch/issues/175\n    const fetchFunc = self.options.fetch;\n    fetchFunc(endpoint, options)\n      .then(self._handleErrors)\n      .then(response => {\n        eventTarget.dispatchEvent(new Event('open'));\n        let jsonStreamBuf = '';\n        let jsonStreamPos = 0;\n        let protoStreamBuf = new Uint8Array();\n        const reader = response.body.getReader();\n        return new self.options.readableStream({\n          start(controller) {\n            function pump() {\n              return reader.read().then(({ done, value }) => {\n                // When no more data needs to be consumed, close the stream\n                if (done) {\n                  eventTarget.dispatchEvent(new Event('close'));\n                  controller.close();\n                  return;\n                }\n                try {\n                  if (self._protocol === 'json') {\n                    jsonStreamBuf += self._utf8decoder.decode(value);\n                    while (jsonStreamPos < jsonStreamBuf.length) {\n                      if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                        const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                        eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                        jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                        jsonStreamPos = 0;\n                      } else {\n                        ++jsonStreamPos;\n                      }\n                    }\n                  } else {\n                    const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n                    mergedArray.set(protoStreamBuf);\n                    mergedArray.set(value, protoStreamBuf.length);\n                    protoStreamBuf = mergedArray;\n\n                    while (true) {\n                      const result = self.options.decoder.decodeReply(protoStreamBuf);\n                      if (result.ok) {\n                        const data = protoStreamBuf.slice(0, result.pos);\n                        eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                        protoStreamBuf = protoStreamBuf.slice(result.pos);\n                        continue;\n                      }\n                      break;\n                    }\n                  }\n                } catch (error) {\n                  // @ts-ignore - improve later.\n                  eventTarget.dispatchEvent(new Event('error', { detail: error }));\n                  eventTarget.dispatchEvent(new Event('close'));\n                  controller.close();\n                  return;\n                }\n                pump();\n              }).catch(function (e) {\n                // @ts-ignore - improve later.\n                eventTarget.dispatchEvent(new Event('error', { detail: e }));\n                eventTarget.dispatchEvent(new Event('close'));\n                controller.close();\n                return;\n              });\n            }\n            return pump();\n          }\n        });\n      })\n      .catch(error => {\n        // @ts-ignore - improve later.\n        eventTarget.dispatchEvent(new Event('error', { detail: error }));\n        eventTarget.dispatchEvent(new Event('close'));\n      });\n    return eventTarget;\n  }\n\n  supported() {\n    return this.options.fetch !== null &&\n      this.options.readableStream !== null &&\n      typeof TextDecoder !== 'undefined' &&\n      typeof AbortController !== 'undefined' &&\n      typeof EventTarget !== 'undefined' &&\n      typeof Event !== 'undefined' &&\n      typeof MessageEvent !== 'undefined' &&\n      typeof Error !== 'undefined';\n  }\n\n  initialize(protocol: string, callbacks: any, initialData: any) {\n    this._protocol = protocol;\n    this._abortController = new AbortController();\n    let headers: any;\n    let body: any;\n    if (protocol === 'json') {\n      headers = {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      };\n      body = initialData;\n    } else {\n      headers = {\n        'Accept': 'application/octet-stream',\n        'Content-Type': 'application/octet-stream'\n      };\n      body = initialData;\n    }\n\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n      signal: this._abortController.signal\n    }\n\n    const eventTarget = this._fetchEventTarget(\n      this,\n      this.endpoint,\n      fetchOptions\n    );\n\n    eventTarget.addEventListener('open', () => {\n      callbacks.onOpen();\n    });\n\n    eventTarget.addEventListener('error', (e) => {\n      this._abortController.abort();\n      callbacks.onError(e);\n    });\n\n    eventTarget.addEventListener('close', () => {\n      this._abortController.abort();\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n\n    eventTarget.addEventListener('message', (e: any) => {\n      callbacks.onMessage(e.data);\n    });\n  }\n\n  close() {\n    this._abortController.abort();\n  }\n\n  send(data: any, session: string, node: string) {\n    let headers: any;\n    let body: any;\n    const req = {\n      session: session,\n      node: node,\n      data: data\n    };\n    if (this._protocol === 'json') {\n      headers = {\n        'Content-Type': 'application/json'\n      };\n      body = JSON.stringify(req);\n    } else {\n      headers = {\n        'Content-Type': 'application/octet-stream'\n      };\n      body = this.options.encoder.encodeEmulationRequest(req);\n    }\n\n    const fetchFunc = this.options.fetch;\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n    }\n    fetchFunc(this.options.emulationEndpoint, fetchOptions);\n  }\n}\n", "/** @internal */\nexport class SseTransport {\n  endpoint: string;\n  options: any;\n  _protocol: string;\n  _transport: any;\n  _onClose: any;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._protocol = 'json';\n    this._transport = null;\n    this._onClose = null;\n  }\n\n  name() {\n    return 'sse';\n  }\n\n  subName() {\n    return 'sse';\n  }\n\n  emulation() {\n    return true;\n  }\n\n  supported() {\n    return this.options.eventsource !== null && this.options.fetch !== null;\n  }\n\n  initialize(_protocol: 'json', callbacks: any, initialData: any) {\n    let url: any;\n    if (globalThis && globalThis.document && globalThis.document.baseURI) {\n      // Handle case when endpoint is relative, like //example.com/connection/sse\n      url = new URL(this.endpoint, globalThis.document.baseURI);\n    } else {\n      url = new URL(this.endpoint);\n    }\n    url.searchParams.append('cf_connect', initialData);\n\n    const eventsourceOptions = {}\n    const eventSource = new this.options.eventsource(url.toString(), eventsourceOptions);\n    this._transport = eventSource;\n\n    const self = this;\n\n    eventSource.onopen = function () {\n      callbacks.onOpen();\n    };\n\n    eventSource.onerror = function (e) {\n      eventSource.close();\n      callbacks.onError(e);\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    };\n\n    eventSource.onmessage = function (e) {\n      callbacks.onMessage(e.data);\n    };\n\n    self._onClose = function () {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    };\n  }\n\n  close() {\n    this._transport.close();\n    if (this._onClose !== null) {\n      this._onClose();\n    }\n  }\n\n  send(data: any, session: string, node: string) {\n    const req = {\n      session: session,\n      node: node,\n      data: data\n    };\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n    const body = JSON.stringify(req);\n    const fetchFunc = this.options.fetch;\n    const fetchOptions = {\n      method: 'POST',\n      headers: headers,\n      body: body,\n      mode: 'cors',\n      credentials: 'same-origin',\n    }\n    fetchFunc(this.options.emulationEndpoint, fetchOptions);\n  }\n}\n", "/** @internal */\nexport class WebtransportTransport {\n  private _transport: any;\n  private _stream: any;\n  private _writer: any;\n  private endpoint: string;\n  private options: any;\n  _utf8decoder: TextDecoder;\n  _protocol: string;\n\n  constructor(endpoint: string, options: any) {\n    this.endpoint = endpoint;\n    this.options = options;\n    this._transport = null;\n    this._stream = null;\n    this._writer = null;\n    this._utf8decoder = new TextDecoder();\n    this._protocol = 'json';\n  }\n\n  name() {\n    return 'webtransport';\n  }\n\n  subName() {\n    return 'webtransport';\n  }\n\n  emulation() {\n    return false;\n  }\n\n  supported() {\n    return this.options.webtransport !== undefined && this.options.webtransport !== null;\n  }\n\n  async initialize(protocol: string, callbacks: any) {\n    let url: any;\n    if (globalThis && globalThis.document && globalThis.document.baseURI) {\n      // Handle case when endpoint is relative, like //example.com/connection/webtransport\n      url = new URL(this.endpoint, globalThis.document.baseURI);\n    } else {\n      url = new URL(this.endpoint);\n    }\n    if (protocol === 'protobuf') {\n      url.searchParams.append('cf_protocol', 'protobuf');\n    }\n\n    this._protocol = protocol;\n    const eventTarget = new EventTarget();\n\n    this._transport = new this.options.webtransport(url.toString());\n    this._transport.closed.then(() => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    }).catch(() => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n    try {\n      await this._transport.ready;\n    } catch {\n      this.close();\n      return;\n    }\n    let stream: any;\n    try {\n      stream = await this._transport.createBidirectionalStream();\n    } catch {\n      this.close();\n      return;\n    }\n    this._stream = stream;\n    this._writer = this._stream.writable.getWriter();\n\n    eventTarget.addEventListener('close', () => {\n      callbacks.onClose({\n        code: 4,\n        reason: 'connection closed'\n      });\n    });\n\n    eventTarget.addEventListener('message', (e: any) => {\n      callbacks.onMessage(e.data);\n    });\n\n    this._startReading(eventTarget);\n\n    callbacks.onOpen();\n  }\n\n  async _startReading(eventTarget: any) {\n    const reader = this._stream.readable.getReader();\n    let jsonStreamBuf = '';\n    let jsonStreamPos = 0;\n    let protoStreamBuf = new Uint8Array();\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (value.length > 0) {\n          if (this._protocol === 'json') {\n            jsonStreamBuf += this._utf8decoder.decode(value);\n            while (jsonStreamPos < jsonStreamBuf.length) {\n              if (jsonStreamBuf[jsonStreamPos] === '\\n') {\n                const line = jsonStreamBuf.substring(0, jsonStreamPos);\n                eventTarget.dispatchEvent(new MessageEvent('message', { data: line }));\n                jsonStreamBuf = jsonStreamBuf.substring(jsonStreamPos + 1);\n                jsonStreamPos = 0;\n              } else {\n                ++jsonStreamPos;\n              }\n            }\n          } else {\n            const mergedArray = new Uint8Array(protoStreamBuf.length + value.length);\n            mergedArray.set(protoStreamBuf);\n            mergedArray.set(value, protoStreamBuf.length);\n            protoStreamBuf = mergedArray;\n\n            while (true) {\n              const result = this.options.decoder.decodeReply(protoStreamBuf);\n              if (result.ok) {\n                const data = protoStreamBuf.slice(0, result.pos);\n                eventTarget.dispatchEvent(new MessageEvent('message', { data: data }));\n                protoStreamBuf = protoStreamBuf.slice(result.pos);\n                continue;\n              }\n              break;\n            }\n          }\n        }\n        if (done) {\n          break;\n        }\n      }\n    } catch {\n      eventTarget.dispatchEvent(new Event('close'));\n    }\n  }\n\n  async close() {\n    try {\n      if (this._writer) {\n        await this._writer.close();\n      }\n      this._transport.close();\n    } catch (e) {\n      // already closed.\n    }\n  }\n\n  async send(data: any) {\n    let binary: Uint8Array;\n    if (this._protocol === 'json') {\n      // Need extra \\n since WT is non-frame protocol. \n      binary = new TextEncoder().encode(data + '\\n');\n    } else {\n      binary = data;\n    }\n    try {\n      await this._writer.write(binary);\n    } catch (e) {\n      this.close();\n    }\n  }\n}\n", "/*\nCopyright 2014-2024 Dmitry Chestnykh (JavaScript port)\nCopyright 2007 D. Richard Hipp  (original C version)\n\nFossil SCM delta compression algorithm, this is only the applyDelta part extracted\nfrom https://github.com/dchest/fossil-delta-js. The code was slightly modified\nto strip unnecessary parts. The copyright on top of this file is from the original\nrepo on Github licensed under Simplified BSD License.\n*/\n\n// We accept plain arrays of bytes or Uint8Array.\ntype ByteArray = number[] | Uint8Array;\n\n\nconst zValue = [\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1,\n  -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n  24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, 36, -1, 37,\n  38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,\n  57, 58, 59, 60, 61, 62, -1, -1, -1, 63, -1,\n];\n\n// Reader reads bytes, chars, ints from array.\nclass Reader {\n  public a: ByteArray;\n  public pos: number;\n\n  constructor(array: ByteArray) {\n    this.a = array; // source array\n    this.pos = 0; // current position in array\n  }\n\n  haveBytes() {\n    return this.pos < this.a.length;\n  }\n\n  getByte() {\n    const b = this.a[this.pos];\n    this.pos++;\n    if (this.pos > this.a.length) throw new RangeError(\"out of bounds\");\n    return b;\n  }\n\n  getChar() {\n    return String.fromCharCode(this.getByte());\n  }\n\n  // Read base64-encoded unsigned integer.\n  getInt() {\n    let v = 0;\n    let c: number;\n    while (this.haveBytes() && (c = zValue[0x7f & this.getByte()]) >= 0) {\n      v = (v << 6) + c;\n    }\n    this.pos--;\n    return v >>> 0;\n  }\n}\n\n// Write writes an array.\nclass Writer {\n  private a: number[] = [];\n\n  toByteArray<T extends ByteArray>(sourceType: T): T {\n    if (Array.isArray(sourceType)) {\n      return this.a as T;\n    }\n    return new Uint8Array(this.a) as T;\n  }\n\n  // Copy from array at start to end.\n  putArray(a: ByteArray, start: number, end: number) {\n    // TODO: optimize.\n    for (let i = start; i < end; i++) this.a.push(a[i]);\n  }\n}\n\n// Return a 32-bit checksum of the array.\nfunction checksum(arr: ByteArray): number {\n  let sum0 = 0,\n    sum1 = 0,\n    sum2 = 0,\n    sum3 = 0,\n    z = 0,\n    N = arr.length;\n  //TODO measure if this unrolling is helpful.\n  while (N >= 16) {\n    sum0 = (sum0 + arr[z + 0]) | 0;\n    sum1 = (sum1 + arr[z + 1]) | 0;\n    sum2 = (sum2 + arr[z + 2]) | 0;\n    sum3 = (sum3 + arr[z + 3]) | 0;\n\n    sum0 = (sum0 + arr[z + 4]) | 0;\n    sum1 = (sum1 + arr[z + 5]) | 0;\n    sum2 = (sum2 + arr[z + 6]) | 0;\n    sum3 = (sum3 + arr[z + 7]) | 0;\n\n    sum0 = (sum0 + arr[z + 8]) | 0;\n    sum1 = (sum1 + arr[z + 9]) | 0;\n    sum2 = (sum2 + arr[z + 10]) | 0;\n    sum3 = (sum3 + arr[z + 11]) | 0;\n\n    sum0 = (sum0 + arr[z + 12]) | 0;\n    sum1 = (sum1 + arr[z + 13]) | 0;\n    sum2 = (sum2 + arr[z + 14]) | 0;\n    sum3 = (sum3 + arr[z + 15]) | 0;\n\n    z += 16;\n    N -= 16;\n  }\n  while (N >= 4) {\n    sum0 = (sum0 + arr[z + 0]) | 0;\n    sum1 = (sum1 + arr[z + 1]) | 0;\n    sum2 = (sum2 + arr[z + 2]) | 0;\n    sum3 = (sum3 + arr[z + 3]) | 0;\n    z += 4;\n    N -= 4;\n  }\n  sum3 = (((((sum3 + (sum2 << 8)) | 0) + (sum1 << 16)) | 0) + (sum0 << 24)) | 0;\n  switch (N) {\n    //@ts-ignore fallthrough is needed.\n    case 3:\n      sum3 = (sum3 + (arr[z + 2] << 8)) | 0; /* falls through */\n    //@ts-ignore fallthrough is needed.\n    case 2:\n      sum3 = (sum3 + (arr[z + 1] << 16)) | 0; /* falls through */\n    case 1:\n      sum3 = (sum3 + (arr[z + 0] << 24)) | 0; /* falls through */\n  }\n  return sum3 >>> 0;\n}\n\n/**\n * Apply a delta byte array to a source byte array, returning the target byte array.\n */\nexport function applyDelta<T extends ByteArray>(\n  source: T,\n  delta: T\n): T {\n  let total = 0;\n  const zDelta = new Reader(delta);\n  const lenSrc = source.length;\n  const lenDelta = delta.length;\n\n  const limit = zDelta.getInt();\n  if (zDelta.getChar() !== \"\\n\")\n    throw new Error(\"size integer not terminated by '\\\\n'\");\n  const zOut = new Writer();\n  while (zDelta.haveBytes()) {\n    const cnt = zDelta.getInt();\n    let ofst: number;\n\n    switch (zDelta.getChar()) {\n      case \"@\":\n        ofst = zDelta.getInt();\n        if (zDelta.haveBytes() && zDelta.getChar() !== \",\")\n          throw new Error(\"copy command not terminated by ','\");\n        total += cnt;\n        if (total > limit) throw new Error(\"copy exceeds output file size\");\n        if (ofst + cnt > lenSrc)\n          throw new Error(\"copy extends past end of input\");\n        zOut.putArray(source, ofst, ofst + cnt);\n        break;\n\n      case \":\":\n        total += cnt;\n        if (total > limit)\n          throw new Error(\n            \"insert command gives an output larger than predicted\"\n          );\n        if (cnt > lenDelta)\n          throw new Error(\"insert count exceeds size of delta\");\n        zOut.putArray(zDelta.a, zDelta.pos, zDelta.pos + cnt);\n        zDelta.pos += cnt;\n        break;\n\n      case \";\":\n        {\n          const out = zOut.toByteArray(source);\n          if (cnt !== checksum(out))\n            throw new Error(\"bad checksum\");\n          if (total !== limit)\n            throw new Error(\"generated size does not match predicted size\");\n          return out;\n        }\n      default:\n        throw new Error(\"unknown delta operator\");\n    }\n  }\n  throw new Error(\"unterminated delta\");\n}\n", "import { applyDelta } from './fossil';\n\n/** @internal */\nexport class JsonCodec {\n  name() {\n    return 'json';\n  }\n\n  encodeCommands(commands: any[]): string {\n    return commands.map(c => JSON.stringify(c)).join('\\n');\n  }\n\n  decodeReplies(data: string): any[] {\n    return data.trim().split('\\n').map(r => JSON.parse(r));\n  }\n\n  applyDeltaIfNeeded(pub: any, prevValue: any) {\n    let newData: any, newPrevValue: any;\n    if (pub.delta) {\n      // JSON string delta.\n      const valueArray = applyDelta(prevValue, new TextEncoder().encode(pub.data));\n      newData = JSON.parse(new TextDecoder().decode(valueArray))\n      newPrevValue = valueArray;\n    } else {\n      // Full data as JSON string.\n      newData = JSON.parse(pub.data);\n      newPrevValue = new TextEncoder().encode(pub.data);\n    }\n    return { newData, newPrevValue }\n  }\n}\n", "import { Subscription } from './subscription';\nimport {\n  errorCodes, disconnectedCodes,\n  connectingCodes, subscribingCodes\n} from './codes';\n\nimport { SockjsTransport } from './transport_sockjs';\nimport { WebsocketTransport } from './transport_websocket';\nimport { HttpStreamTransport } from './transport_http_stream';\nimport { SseTransport } from './transport_sse';\nimport { WebtransportTransport } from './transport_webtransport';\n\nimport { JsonCodec } from './json';\n\nimport {\n  isFunction, log, startsWith, errorExists,\n  backoff, ttlMilliseconds\n} from './utils';\n\nimport {\n  State, Options, SubscriptionState, ClientEvents,\n  TypedEventEmitter, RpcResult, SubscriptionOptions,\n  HistoryOptions, HistoryResult, PublishResult,\n  PresenceResult, PresenceStatsResult, SubscribedContext,\n  TransportEndpoint,\n} from './types';\n\nimport EventEmitter from 'events';\n\nconst defaults: Options = {\n  headers: {},\n  token: '',\n  getToken: null,\n  data: null,\n  getData: null,\n  debug: false,\n  name: 'js',\n  version: '',\n  fetch: null,\n  readableStream: null,\n  websocket: null,\n  eventsource: null,\n  sockjs: null,\n  sockjsOptions: {},\n  emulationEndpoint: '/emulation',\n  minReconnectDelay: 500,\n  maxReconnectDelay: 20000,\n  timeout: 5000,\n  maxServerPingDelay: 10000,\n  networkEventTarget: null,\n}\n\ninterface serverSubscription {\n  offset: number;\n  epoch: string;\n  recoverable: boolean;\n}\n\ntype CallResolveContext = { reply: any; next?: () => void };\ntype CallRejectContext = { error: any; next?: () => void };\n\nexport class UnauthorizedError extends Error {\n  constructor(message: any) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\n/** Centrifuge is a Centrifuge/Centrifugo bidirectional client. */\nexport class Centrifuge extends (EventEmitter as new () => TypedEventEmitter<ClientEvents>) {\n  state: State;\n  private _transportIsOpen: boolean;\n  private _endpoint: string | Array<TransportEndpoint>;\n  private _emulation: boolean;\n  private _transports: any[];\n  private _currentTransportIndex: number;\n  private _triedAllTransports: boolean;\n  private _transportWasOpen: boolean;\n  private _transport?: any;\n  private _transportId: number;\n  private _deviceWentOffline: boolean;\n  private _transportClosed: boolean;\n  private _reconnecting: boolean;\n  private _reconnectTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _reconnectAttempts: number;\n  private _client: null;\n  private _session: string;\n  private _node: string;\n  private _subs: Record<string, Subscription>;\n  private _serverSubs: Record<string, serverSubscription>;\n  private _commandId: number;\n  private _commands: any[];\n  private _batching: boolean;\n  private _refreshRequired: boolean;\n  private _refreshTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _callbacks: Record<number, any>;\n  private _token: string;\n  private _data: any;\n  private _dispatchPromise: Promise<void>;\n  private _serverPing: number;\n  private _serverPingTimeout?: null | ReturnType<typeof setTimeout> = null;\n  private _sendPong: boolean;\n  private _promises: Record<number, any>;\n  private _promiseId: number;\n  private _networkEventsSet: boolean;\n\n  private _debugEnabled: boolean;\n  private _config: Options;\n  protected _codec: any;\n\n  static SubscriptionState: typeof SubscriptionState;\n  static State: typeof State;\n  static UnauthorizedError: typeof UnauthorizedError;\n\n  /** Constructs Centrifuge client. Call connect() method to start connecting. */\n  constructor(endpoint: string | Array<TransportEndpoint>, options?: Partial<Options>) {\n    super();\n    this.state = State.Disconnected;\n    this._transportIsOpen = false;\n    this._endpoint = endpoint;\n    this._emulation = false;\n    this._transports = [];\n    this._currentTransportIndex = 0;\n    this._triedAllTransports = false;\n    this._transportWasOpen = false;\n    this._transport = null;\n    this._transportId = 0;\n    this._deviceWentOffline = false;\n    this._transportClosed = true;\n    this._codec = new JsonCodec();\n    this._reconnecting = false;\n    this._reconnectTimeout = null;\n    this._reconnectAttempts = 0;\n    this._client = null;\n    this._session = '';\n    this._node = '';\n    this._subs = {};\n    this._serverSubs = {};\n    this._commandId = 0;\n    this._commands = [];\n    this._batching = false;\n    this._refreshRequired = false;\n    this._refreshTimeout = null;\n    this._callbacks = {};\n    this._token = '';\n    this._data = null;\n    this._dispatchPromise = Promise.resolve();\n    this._serverPing = 0;\n    this._serverPingTimeout = null;\n    this._sendPong = false;\n    this._promises = {};\n    this._promiseId = 0;\n    this._debugEnabled = false;\n    this._networkEventsSet = false;\n\n    this._config = { ...defaults, ...options };\n    this._configure();\n\n    if (this._debugEnabled) {\n      this.on('state', (ctx) => {\n        this._debug('client state', ctx.oldState, '->', ctx.newState);\n      });\n      this.on('error', (ctx) => {\n        this._debug('client error', ctx);\n      });\n    } else {\n      // Avoid unhandled exception in EventEmitter for non-set error handler.\n      this.on('error', function () { Function.prototype(); });\n    }\n  }\n\n  /** newSubscription allocates new Subscription to a channel. Since server only allows \n   * one subscription per channel per client this method throws if client already has \n   * channel subscription in internal registry.\n   * */\n  newSubscription(channel: string, options?: Partial<SubscriptionOptions>): Subscription {\n    if (this.getSubscription(channel) !== null) {\n      throw new Error('Subscription to the channel ' + channel + ' already exists');\n    }\n    const sub = new Subscription(this, channel, options);\n    this._subs[channel] = sub;\n    return sub;\n  }\n\n  /** getSubscription returns Subscription if it's registered in the internal \n   * registry or null. */\n  getSubscription(channel: string): Subscription | null {\n    return this._getSub(channel);\n  }\n\n  /** removeSubscription allows removing Subcription from the internal registry. */\n  removeSubscription(sub: Subscription | null) {\n    if (!sub) {\n      return;\n    }\n    if (sub.state !== SubscriptionState.Unsubscribed) {\n      sub.unsubscribe();\n    }\n    this._removeSubscription(sub);\n  }\n\n  /** Get a map with all current client-side subscriptions. */\n  subscriptions(): Record<string, Subscription> {\n    return this._subs;\n  }\n\n  /** ready returns a Promise which resolves upon client goes to Connected \n   * state and rejects in case of client goes to Disconnected or Failed state.\n   * Users can provide optional timeout in milliseconds. */\n  async ready(timeout?: number): Promise<void> {\n    switch (this.state) {\n      case State.Disconnected:\n        throw { code: errorCodes.clientDisconnected, message: 'client disconnected' };\n\n      case State.Connected:\n        return;\n\n      default:\n        return new Promise((resolve, reject) => {\n          const ctx: any = { resolve, reject };\n\n          if (timeout) {\n            ctx.timeout = setTimeout(() => {\n              reject({ code: errorCodes.timeout, message: 'timeout' });\n            }, timeout);\n          }\n\n          this._promises[this._nextPromiseId()] = ctx;\n        });\n    }\n  }\n\n  /** connect to a server. */\n  connect() {\n    if (this._isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._isConnecting()) {\n      this._debug('connect called when already connecting');\n      return;\n    }\n    this._debug('connect called');\n    this._reconnectAttempts = 0;\n    this._startConnecting();\n  }\n\n  /** disconnect from a server. */\n  disconnect() {\n    this._disconnect(disconnectedCodes.disconnectCalled, 'disconnect called', false);\n  }\n\n  /** setToken allows setting connection token. Or resetting used token to be empty.  */\n  setToken(token: string) {\n    this._token = token;\n  }\n\n  /** setData allows setting connection data. This only affects the next connection attempt,\n   * not the current one. Note that if getData callback is configured, it will override\n   * this value during reconnects. */\n  setData(data: any) {\n    this._data = data;\n  }\n\n  /** setHeaders allows setting connection emulated headers. */\n  setHeaders(headers: { [key: string]: string }) {\n    this._config.headers = headers;\n  }\n\n  /** send asynchronous data to a server (without any response from a server \n   * expected, see rpc method if you need response). */\n  async send(data: any): Promise<void> {\n    const cmd = {\n      send: {\n        data\n      }\n    };\n\n    await this._methodCall();\n\n    const sent = this._transportSendCommands([cmd]); // can send message to server without id set\n\n    if (!sent) {\n      throw this._createErrorObject(\n        errorCodes.transportWriteError,\n        'transport write error'\n      );\n    }\n  }\n\n  /** rpc to a server - i.e. a call which waits for a response with data. */\n  async rpc(method: string, data: any): Promise<RpcResult> {\n    const cmd = {\n      rpc: {\n        method,\n        data\n      }\n    };\n\n    await this._methodCall();\n    const result = await this._callPromise(cmd, (reply: any) => reply.rpc);\n    return {\n      data: result.data\n    };\n  }\n\n  /** publish data to a channel. */\n  async publish(channel: string, data: any): Promise<PublishResult> {\n    const cmd = {\n      publish: {\n        channel,\n        data\n      }\n    };\n\n    await this._methodCall();\n    await this._callPromise(cmd, () => ({}));\n    return {};\n  }\n\n  /** history for a channel. By default it does not return publications (only current\n   *  StreamPosition data) \u2013 provide an explicit limit > 0 to load publications.*/\n  async history(channel: string, options?: HistoryOptions): Promise<HistoryResult> {\n    const cmd = {\n      history: this._getHistoryRequest(channel, options)\n    };\n\n    await this._methodCall();\n\n    const result = await this._callPromise(cmd, (reply: any) => reply.history);\n\n    const publications: any[] = [];\n\n    if (result.publications) {\n      for (let i = 0; i < result.publications.length; i++) {\n        publications.push(this._getPublicationContext(channel, result.publications[i]));\n      }\n    }\n\n    return {\n      publications,\n      epoch: result.epoch || '',\n      offset: result.offset || 0\n    };\n  }\n\n  /** presence for a channel. */\n  async presence(channel: string): Promise<PresenceResult> {\n    const cmd = {\n      presence: {\n        channel\n      }\n    };\n\n    await this._methodCall();\n    const result = await this._callPromise(cmd, (reply: any) => reply.presence);\n\n    const clients = result.presence;\n\n    for (const clientId in clients) {\n      if (Object.prototype.hasOwnProperty.call(clients, clientId)) {\n        const rawClient = clients[clientId];\n        const connInfo = rawClient['conn_info'];\n        const chanInfo = rawClient['chan_info'];\n        if (connInfo) {\n          rawClient.connInfo = connInfo;\n        }\n        if (chanInfo) {\n          rawClient.chanInfo = chanInfo;\n        }\n      }\n    }\n\n    return { clients };\n  }\n\n  async presenceStats(channel: string): Promise<PresenceStatsResult> {\n    const cmd: any = {\n      'presence_stats': {\n        channel\n      }\n    };\n\n    await this._methodCall();\n\n    const result = await this._callPromise(cmd, (reply: any) => {\n      return reply.presence_stats;\n    });\n\n    return {\n      numUsers: result.num_users,\n      numClients: result.num_clients\n    };\n  }\n\n  /** start command batching (collect into temporary buffer without sending to a server) \n   * until stopBatching called.*/\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._batching = true;\n  }\n\n  /** stop batching commands and flush collected commands to the \n   * network (all in one request/frame).*/\n  stopBatching() {\n    const self = this;\n    // Why so nested? Two levels here requred to deal with promise resolving queue.\n    // In Subscription case we wait 2 futures before sending data to connection.\n    // Otherwise _batching becomes false before batching decision has a chance to be executed.\n    Promise.resolve().then(function () {\n      Promise.resolve().then(function () {\n        self._batching = false;\n        self._flush();\n      })\n    })\n  }\n\n  private _debug(...args: any[]) {\n    if (!this._debugEnabled) {\n      return;\n    }\n    log('debug', args);\n  }\n\n  private _codecName(): string {\n    return this._codec.name()\n  }\n\n  /** @internal */\n  protected _formatOverride() {\n    return;\n  }\n\n  private _configure() {\n    if (!('Promise' in globalThis)) {\n      throw new Error('Promise polyfill required');\n    }\n\n    if (!this._endpoint) {\n      throw new Error('endpoint configuration required');\n    }\n\n    if (this._config.token !== null) {\n      this._token = this._config.token;\n    }\n\n    if (this._config.data !== null) {\n      this._data = this._config.data;\n    }\n\n    this._codec = new JsonCodec();\n    this._formatOverride();\n\n    if (this._config.debug === true ||\n      (typeof localStorage !== 'undefined' && typeof localStorage.getItem === 'function' && localStorage.getItem('centrifuge.debug'))) {\n      this._debugEnabled = true;\n    }\n\n    this._debug('config', this._config);\n\n    if (typeof this._endpoint === 'string') {\n      // Single address.\n    } else if (Array.isArray(this._endpoint)) {\n      this._transports = this._endpoint;\n      this._emulation = true;\n      for (const i in this._transports) {\n        if (this._transports.hasOwnProperty(i)) {\n          const transportConfig = this._transports[i];\n          if (!transportConfig.endpoint || !transportConfig.transport) {\n            throw new Error('malformed transport configuration');\n          }\n          const transportName = transportConfig.transport;\n          if (['websocket', 'http_stream', 'sse', 'sockjs', 'webtransport'].indexOf(transportName) < 0) {\n            throw new Error('unsupported transport name: ' + transportName);\n          }\n        }\n      }\n    } else {\n      throw new Error('unsupported url configuration type: only string or array of objects are supported');\n    }\n  }\n\n  private _setState(newState: State) {\n    if (this.state !== newState) {\n      this._reconnecting = false;\n      const oldState = this.state;\n      this.state = newState;\n      this.emit('state', { newState, oldState });\n      return true;\n    }\n    return false;\n  }\n\n  private _isDisconnected() {\n    return this.state === State.Disconnected;\n  }\n\n  private _isConnecting() {\n    return this.state === State.Connecting;\n  }\n\n  private _isConnected() {\n    return this.state === State.Connected;\n  }\n\n  private _nextCommandId() {\n    return ++this._commandId;\n  }\n\n  private _setNetworkEvents() {\n    if (this._networkEventsSet) {\n      return;\n    }\n    let eventTarget: EventTarget | null = null;\n    if (this._config.networkEventTarget !== null) {\n      eventTarget = this._config.networkEventTarget;\n    } else if (typeof globalThis.addEventListener !== 'undefined') {\n      eventTarget = globalThis as EventTarget;\n    }\n    if (eventTarget) {\n      eventTarget.addEventListener('offline', () => {\n        this._debug('offline event triggered');\n        if (this.state === State.Connected || this.state === State.Connecting) {\n          this._disconnect(connectingCodes.transportClosed, 'transport closed', true);\n          this._deviceWentOffline = true;\n        }\n      });\n      eventTarget.addEventListener('online', () => {\n        this._debug('online event triggered');\n        if (this.state !== State.Connecting) {\n          return;\n        }\n        if (this._deviceWentOffline && !this._transportClosed) {\n          // This is a workaround for mobile Safari where close callback may be\n          // not issued upon device going to the flight mode. We know for sure\n          // that transport close was called, so we start reconnecting. In this\n          // case if the close callback will be issued for some reason after some\n          // time \u2013 it will be ignored due to transport ID mismatch.\n          this._deviceWentOffline = false;\n          this._transportClosed = true;\n        }\n        this._clearReconnectTimeout();\n        this._startReconnecting();\n      });\n      this._networkEventsSet = true;\n    }\n  }\n\n  private _getReconnectDelay() {\n    const delay = backoff(this._reconnectAttempts, this._config.minReconnectDelay, this._config.maxReconnectDelay);\n    this._reconnectAttempts += 1;\n    return delay;\n  }\n\n  private _clearOutgoingRequests() {\n    // fire errbacks of registered outgoing calls.\n    for (const id in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(id)) {\n        const callbacks = this._callbacks[id];\n        clearTimeout(callbacks.timeout);\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback({ error: this._createErrorObject(errorCodes.connectionClosed, 'connection closed') });\n      }\n    }\n    this._callbacks = {};\n  }\n\n  private _clearConnectedState() {\n    this._client = null;\n    this._clearServerPingTimeout();\n    this._clearRefreshTimeout();\n\n    // fire events for client-side subscriptions.\n    for (const channel in this._subs) {\n      if (!this._subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = this._subs[channel];\n      if (sub.state === SubscriptionState.Subscribed) {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        sub._setSubscribing(subscribingCodes.transportClosed, 'transport closed');\n      }\n    }\n\n    // fire events for server-side subscriptions.\n    for (const channel in this._serverSubs) {\n      if (this._serverSubs.hasOwnProperty(channel)) {\n        this.emit('subscribing', { channel: channel });\n      }\n    }\n  }\n\n  private _handleWriteError(commands: any[]) {\n    for (const command of commands) {\n      const id = command.id;\n      if (!(id in this._callbacks)) {\n        continue;\n      }\n      const callbacks = this._callbacks[id];\n      clearTimeout(this._callbacks[id].timeout);\n      delete this._callbacks[id];\n      const errback = callbacks.errback;\n      errback({ error: this._createErrorObject(errorCodes.transportWriteError, 'transport write error') });\n    }\n  }\n\n  private _transportSendCommands(commands: any[]) {\n    if (!commands.length) {\n      return true;\n    }\n    if (!this._transport) {\n      return false\n    }\n    try {\n      this._transport.send(this._codec.encodeCommands(commands), this._session, this._node);\n    } catch (e) {\n      this._debug('error writing commands', e);\n      this._handleWriteError(commands);\n      return false;\n    }\n    return true;\n  }\n\n  private _initializeTransport() {\n    let websocket: any;\n    if (this._config.websocket !== null) {\n      websocket = this._config.websocket;\n    } else {\n      if (!(typeof globalThis.WebSocket !== 'function' && typeof globalThis.WebSocket !== 'object')) {\n        websocket = globalThis.WebSocket;\n      }\n    }\n\n    let sockjs = null;\n    if (this._config.sockjs !== null) {\n      sockjs = this._config.sockjs;\n    } else {\n      if (typeof globalThis.SockJS !== 'undefined') {\n        sockjs = globalThis.SockJS;\n      }\n    }\n\n    let eventsource: any = null;\n    if (this._config.eventsource !== null) {\n      eventsource = this._config.eventsource;\n    } else {\n      if (typeof globalThis.EventSource !== 'undefined') {\n        eventsource = globalThis.EventSource;\n      }\n    }\n\n    let fetchFunc: any = null;\n    if (this._config.fetch !== null) {\n      fetchFunc = this._config.fetch;\n    } else {\n      if (typeof globalThis.fetch !== 'undefined') {\n        fetchFunc = globalThis.fetch;\n      }\n    }\n\n    let readableStream: any = null;\n    if (this._config.readableStream !== null) {\n      readableStream = this._config.readableStream;\n    } else {\n      if (typeof globalThis.ReadableStream !== 'undefined') {\n        readableStream = globalThis.ReadableStream;\n      }\n    }\n\n    if (!this._emulation) {\n      if (startsWith(this._endpoint, 'http')) {\n        throw new Error('Provide explicit transport endpoints configuration in case of using HTTP (i.e. using array of TransportEndpoint instead of a single string), or use ws(s):// scheme in an endpoint if you aimed using WebSocket transport');\n      } else {\n        this._debug('client will use websocket');\n        this._transport = new WebsocketTransport(this._endpoint as string, {\n          websocket: websocket\n        });\n        if (!this._transport.supported()) {\n          throw new Error('WebSocket constructor not found, make sure it is available globally or passed as a dependency in Centrifuge options');\n        }\n      }\n    } else {\n      if (this._currentTransportIndex >= this._transports.length) {\n        this._triedAllTransports = true;\n        this._currentTransportIndex = 0;\n      }\n      let count = 0;\n      while (true) {\n        if (count >= this._transports.length) {\n          throw new Error('no supported transport found');\n        }\n        const transportConfig = this._transports[this._currentTransportIndex];\n        const transportName = transportConfig.transport;\n        const transportEndpoint = transportConfig.endpoint;\n\n        if (transportName === 'websocket') {\n          this._debug('trying websocket transport');\n          this._transport = new WebsocketTransport(transportEndpoint, {\n            websocket: websocket\n          });\n          if (!this._transport.supported()) {\n            this._debug('websocket transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'webtransport') {\n          this._debug('trying webtransport transport');\n          this._transport = new WebtransportTransport(transportEndpoint, {\n            webtransport: globalThis.WebTransport,\n            decoder: this._codec,\n            encoder: this._codec\n          });\n          if (!this._transport.supported()) {\n            this._debug('webtransport transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'http_stream') {\n          this._debug('trying http_stream transport');\n          this._transport = new HttpStreamTransport(transportEndpoint, {\n            fetch: fetchFunc,\n            readableStream: readableStream,\n            emulationEndpoint: this._config.emulationEndpoint,\n            decoder: this._codec,\n            encoder: this._codec\n          });\n          if (!this._transport.supported()) {\n            this._debug('http_stream transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'sse') {\n          this._debug('trying sse transport');\n          this._transport = new SseTransport(transportEndpoint, {\n            eventsource: eventsource,\n            fetch: fetchFunc,\n            emulationEndpoint: this._config.emulationEndpoint,\n          });\n          if (!this._transport.supported()) {\n            this._debug('sse transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else if (transportName === 'sockjs') {\n          this._debug('trying sockjs');\n          this._transport = new SockjsTransport(transportEndpoint, {\n            sockjs: sockjs,\n            sockjsOptions: this._config.sockjsOptions\n          });\n          if (!this._transport.supported()) {\n            this._debug('sockjs transport not available');\n            this._currentTransportIndex++;\n            count++;\n            continue;\n          }\n        } else {\n          throw new Error('unknown transport ' + transportName);\n        }\n        break;\n      }\n    }\n\n    const self = this;\n    const transport = this._transport;\n    const transportId = this._nextTransportId();\n    self._debug(\"id of transport\", transportId);\n    let wasOpen = false;\n    const initialCommands: any[] = [];\n\n    if (this._transport.emulation()) {\n      const connectCommand = self._sendConnect(true);\n      initialCommands.push(connectCommand);\n    }\n\n    this._setNetworkEvents();\n\n    const initialData = this._codec.encodeCommands(initialCommands);\n\n    this._transportClosed = false;\n\n    let connectTimeout: any;\n    connectTimeout = setTimeout(function () {\n      transport.close();\n    }, this._config.timeout);\n\n    this._transport.initialize(this._codecName(), {\n      onOpen: function () {\n        if (connectTimeout) {\n          clearTimeout(connectTimeout);\n          connectTimeout = null;\n        }\n        if (self._transportId != transportId) {\n          self._debug('open callback from non-actual transport');\n          transport.close();\n          return;\n        }\n        wasOpen = true;\n        self._debug(transport.subName(), 'transport open');\n        if (transport.emulation()) {\n          return;\n        }\n        self._transportIsOpen = true;\n        self._transportWasOpen = true;\n        self.startBatching();\n        self._sendConnect(false);\n        self._sendSubscribeCommands();\n        self.stopBatching();\n        //@ts-ignore must be used only for debug and test purposes. Exposed only for non-emulation transport.\n        self.emit('__centrifuge_debug:connect_frame_sent', {})\n      },\n      onError: function (e: any) {\n        if (self._transportId != transportId) {\n          self._debug('error callback from non-actual transport');\n          return;\n        }\n        self._debug('transport level error', e);\n      },\n      onClose: function (closeEvent) {\n        if (connectTimeout) {\n          clearTimeout(connectTimeout);\n          connectTimeout = null;\n        }\n        if (self._transportId != transportId) {\n          self._debug('close callback from non-actual transport');\n          return;\n        }\n        self._debug(transport.subName(), 'transport closed');\n        self._transportClosed = true;\n        self._transportIsOpen = false;\n\n        let reason = 'connection closed';\n        let needReconnect = true;\n        let code = 0;\n\n        if (closeEvent && 'code' in closeEvent && closeEvent.code) {\n          code = closeEvent.code;\n        }\n\n        if (closeEvent && closeEvent.reason) {\n          try {\n            const advice = JSON.parse(closeEvent.reason);\n            reason = advice.reason;\n            needReconnect = advice.reconnect;\n          } catch (e) {\n            reason = closeEvent.reason;\n            if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n              needReconnect = false;\n            }\n          }\n        }\n\n        if (code < 3000) {\n          if (code === 1009) {\n            code = disconnectedCodes.messageSizeLimit;\n            reason = 'message size limit exceeded';\n            needReconnect = false;\n          } else {\n            code = connectingCodes.transportClosed;\n            reason = 'transport closed';\n          }\n          if (self._emulation && !self._transportWasOpen) {\n            self._currentTransportIndex++;\n            if (self._currentTransportIndex >= self._transports.length) {\n              self._triedAllTransports = true;\n              self._currentTransportIndex = 0;\n            }\n          }\n        } else {\n          // Codes >= 3000 are sent from a server application level.\n          self._transportWasOpen = true;\n        }\n\n        if (self._isConnecting() && !wasOpen) {\n          self.emit('error', {\n            type: 'transport',\n            error: {\n              code: errorCodes.transportClosed,\n              message: 'transport closed'\n            },\n            transport: transport.name()\n          });\n        }\n\n        self._reconnecting = false;\n        self._disconnect(code, reason, needReconnect);\n      },\n      onMessage: function (data) {\n        self._dataReceived(data);\n      }\n    }, initialData);\n    //@ts-ignore must be used only for debug and test purposes.\n    self.emit('__centrifuge_debug:transport_initialized', {})\n  }\n\n  private _sendConnect(skipSending: boolean): any {\n    const connectCommand = this._constructConnectCommand();\n    const self = this;\n    this._call(connectCommand, skipSending).then(resolveCtx => {\n      const result = resolveCtx.reply.connect;\n      self._connectResponse(result);\n      if (resolveCtx.next) {\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      self._connectError(rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n    return connectCommand;\n  }\n\n  private _startReconnecting() {\n    this._debug('start reconnecting');\n    if (!this._isConnecting()) {\n      this._debug('stop reconnecting: client not in connecting state');\n      return;\n    }\n    if (this._reconnecting) {\n      this._debug('reconnect already in progress, return from reconnect routine');\n      return;\n    }\n    if (this._transportClosed === false) {\n      this._debug('waiting for transport close');\n      return;\n    }\n\n    this._reconnecting = true;\n    const emptyToken = this._token === '';\n    const needTokenRefresh = this._refreshRequired || (emptyToken && this._config.getToken !== null);\n    if (!needTokenRefresh) {\n      if (this._config.getData) {\n        this._config.getData().then(data => {\n          if (!this._isConnecting()) {\n            return;\n          }\n          this._data = data;\n          this._initializeTransport();\n        })\n        .catch(e => this._handleGetDataError(e));\n      } else {\n        this._initializeTransport();\n      }\n      return;\n    }\n\n    const self = this;\n    this._getToken().then(function (token: string) {\n      if (!self._isConnecting()) {\n        return;\n      }\n      if (token == null || token == undefined) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      self._debug('connection token refreshed');\n      if (self._config.getData) {\n        self._config.getData().then(function (data: any) {\n          if (!self._isConnecting()) {\n            return;\n          }\n          self._data = data;\n          self._initializeTransport();\n        })\n        .catch(e => self._handleGetDataError(e));\n      } else {\n        self._initializeTransport();\n      }\n    }).catch(function (e) {\n      if (!self._isConnecting()) {\n        return;\n      }\n      if (e instanceof UnauthorizedError) {\n        self._failUnauthorized();\n        return;\n      }\n      self.emit('error', {\n        'type': 'connectToken',\n        'error': {\n          code: errorCodes.clientConnectToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      const delay = self._getReconnectDelay();\n      self._debug('error on getting connection token, reconnect after ' + delay + ' milliseconds', e);\n      self._reconnecting = false;\n      self._reconnectTimeout = setTimeout(() => {\n        self._startReconnecting();\n      }, delay);\n    });\n  }\n\n  private _handleGetDataError(e: any): void {\n    if (e instanceof UnauthorizedError) {\n      this._failUnauthorized();\n      return;\n    }\n    this.emit('error', {\n      type: 'connectData',\n      error: {\n        code: errorCodes.badConfiguration,\n        message: e?.toString() || ''\n      }\n    });\n    const delay = this._getReconnectDelay();\n    this._debug('error on getting connect data, reconnect after ' + delay + ' milliseconds', e);\n    this._reconnecting = false;\n    this._reconnectTimeout = setTimeout(() => {\n      this._startReconnecting();\n    }, delay);\n  }\n\n  private _connectError(err: any) {\n    if (this.state !== State.Connecting) {\n      return;\n    }\n    if (err.code === 109) { // token expired.\n      // next connect attempt will try to refresh token.\n      this._refreshRequired = true;\n    }\n    if (err.code < 100 || err.temporary === true || err.code === 109) {\n      this.emit('error', {\n        'type': 'connect',\n        'error': err\n      });\n      this._debug('closing transport due to connect error');\n      this._disconnect(err.code, err.message, true);\n    } else {\n      this._disconnect(err.code, err.message, false);\n    }\n  }\n\n  private _scheduleReconnect() {\n    if (!this._isConnecting()) {\n      return;\n    }\n    let isInitialHandshake = false;\n    if (this._emulation && !this._transportWasOpen && !this._triedAllTransports) {\n      isInitialHandshake = true;\n    }\n    let delay = this._getReconnectDelay();\n    if (isInitialHandshake) {\n      delay = 0;\n    }\n    this._debug('reconnect after ' + delay + ' milliseconds');\n    this._clearReconnectTimeout();\n    this._reconnectTimeout = setTimeout(() => {\n      this._startReconnecting();\n    }, delay);\n  }\n\n  private _constructConnectCommand(): any {\n    const req: any = {};\n\n    if (this._token) {\n      req.token = this._token;\n    }\n    if (this._data) {\n      req.data = this._data;\n    }\n    if (this._config.name) {\n      req.name = this._config.name;\n    }\n    if (this._config.version) {\n      req.version = this._config.version;\n    }\n    if (Object.keys(this._config.headers).length > 0) {\n      req.headers = this._config.headers;\n    }\n\n    const subs = {};\n    let hasSubs = false;\n    for (const channel in this._serverSubs) {\n      if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n        hasSubs = true;\n        const sub = {\n          'recover': true\n        };\n        if (this._serverSubs[channel].offset) {\n          sub['offset'] = this._serverSubs[channel].offset;\n        }\n        if (this._serverSubs[channel].epoch) {\n          sub['epoch'] = this._serverSubs[channel].epoch;\n        }\n        subs[channel] = sub;\n      }\n    }\n    if (hasSubs) {\n      req.subs = subs;\n    }\n    return {\n      connect: req\n    };\n  }\n\n  private _getHistoryRequest(channel: string, options?: HistoryOptions) {\n    const req: any = {\n      channel: channel\n    };\n    if (options !== undefined) {\n      if (options.since) {\n        req.since = {\n          offset: options.since.offset\n        };\n        if (options.since.epoch) {\n          req.since.epoch = options.since.epoch;\n        }\n      }\n      if (options.limit !== undefined) {\n        req.limit = options.limit;\n      }\n      if (options.reverse === true) {\n        req.reverse = true;\n      }\n    }\n    return req;\n  }\n\n  private _methodCall(): any {\n    if (this._isConnected()) {\n      return Promise.resolve();\n    }\n    return new Promise((res, rej) => {\n      const timeout = setTimeout(function () {\n        rej({ code: errorCodes.timeout, message: 'timeout' });\n      }, this._config.timeout);\n      this._promises[this._nextPromiseId()] = {\n        timeout: timeout,\n        resolve: res,\n        reject: rej\n      };\n    });\n  }\n\n  private _callPromise<T = any>(\n    cmd: any,\n    resultCB: (reply: any) => T\n  ): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this._call(cmd, false).then(\n        (resolveCtx: { reply: any; next?: () => void }) => {\n          const result = resultCB(resolveCtx.reply);\n          resolve(result);\n          resolveCtx.next?.();\n        },\n        (rejectCtx: { error: any; next?: () => void }) => {\n          reject(rejectCtx.error);\n          rejectCtx.next?.();\n        }\n      );\n    });\n  }\n\n  private _dataReceived(data) {\n    if (this._serverPing > 0) {\n      this._waitServerPing();\n    }\n    const replies = this._codec.decodeReplies(data);\n    // We have to guarantee order of events in replies processing - i.e. start processing\n    // next reply only when we finished processing of current one. Without syncing things in\n    // this way we could get wrong publication events order as reply promises resolve\n    // on next loop tick so for loop continues before we finished emitting all reply events.\n    this._dispatchPromise = this._dispatchPromise.then(() => {\n      let finishDispatch;\n      this._dispatchPromise = new Promise(resolve => {\n        finishDispatch = resolve;\n      });\n      this._dispatchSynchronized(replies, finishDispatch);\n    });\n  }\n\n  private _dispatchSynchronized(replies: any[], finishDispatch: any) {\n    let p: Promise<unknown> = Promise.resolve();\n    for (const i in replies) {\n      if (replies.hasOwnProperty(i)) {\n        p = p.then(() => {\n          return this._dispatchReply(replies[i]);\n        });\n      }\n    }\n    p = p.then(() => {\n      finishDispatch();\n    });\n  }\n\n  private _dispatchReply(reply: any) {\n    let next: any;\n    const p = new Promise(resolve => {\n      next = resolve;\n    });\n\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      next();\n      return p;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply, next);\n    } else {\n      if (!reply.push) {\n        this._handleServerPing(next);\n      } else {\n        this._handlePush(reply.push, next);\n      }\n    }\n\n    return p;\n  }\n\n  private _call(cmd: any, skipSending: boolean): Promise<CallResolveContext> {\n    return new Promise((resolve, reject) => {\n      cmd.id = this._nextCommandId();\n\n      this._registerCall(\n        cmd.id,\n        resolve as (value: CallResolveContext) => void,\n        reject as (reason: CallRejectContext) => void\n      );\n\n      if (!skipSending) {\n        this._addCommand(cmd);\n      }\n    });\n  }\n\n  private _startConnecting() {\n    this._debug('start connecting');\n    if (this._setState(State.Connecting)) {\n      this.emit('connecting', { code: connectingCodes.connectCalled, reason: 'connect called' });\n    }\n    this._client = null;\n    this._startReconnecting();\n  }\n\n  private _disconnect(code: number, reason: string, reconnect: boolean) {\n    if (this._isDisconnected()) {\n      return;\n    }\n    // we mark transport is closed right away, because _clearConnectedState will move subscriptions to subscribing state\n    // if transport will still be open at this time, subscribe frames will be sent to closing transport\n    this._transportIsOpen = false;\n    const previousState = this.state;\n    this._reconnecting = false;\n\n    const ctx = {\n      code: code,\n      reason: reason\n    };\n\n    let needEvent = false;\n\n    if (reconnect) {\n      needEvent = this._setState(State.Connecting);\n    } else {\n      needEvent = this._setState(State.Disconnected);\n      this._rejectPromises({ code: errorCodes.clientDisconnected, message: 'disconnected' });\n    }\n\n    this._clearOutgoingRequests();\n\n    if (previousState === State.Connecting) {\n      this._clearReconnectTimeout();\n    }\n    if (previousState === State.Connected) {\n      this._clearConnectedState();\n    }\n\n    if (needEvent) {\n      if (this._isConnecting()) {\n        this.emit('connecting', ctx);\n      } else {\n        this.emit('disconnected', ctx);\n      }\n    }\n\n    if (this._transport) {\n      this._debug(\"closing existing transport\");\n      const transport = this._transport;\n      this._transport = null;\n      transport.close(); // Close only after setting this._transport to null to avoid recursion when calling transport close().\n      // Need to mark as closed here, because connect call may be sync called after disconnect,\n      // transport onClose callback will not be called yet\n      this._transportClosed = true;\n      this._nextTransportId();\n    } else {\n      this._debug(\"no transport to close\");\n    }\n    this._scheduleReconnect();\n  }\n\n  private _failUnauthorized() {\n    this._disconnect(disconnectedCodes.unauthorized, 'unauthorized', false);\n  }\n\n  private _getToken(): Promise<string> {\n    this._debug('get connection token');\n    if (!this._config.getToken) {\n      this.emit('error', {\n        type: 'configuration',\n        error: {\n          code: errorCodes.badConfiguration,\n          message: 'token expired but no getToken function set in the configuration'\n        }\n      });\n      return Promise.reject(new UnauthorizedError(''));\n    }\n    return this._config.getToken({});\n  }\n\n  private _refresh() {\n    const clientId = this._client;\n    const self = this;\n    this._getToken().then(function (token) {\n      if (clientId !== self._client) {\n        return;\n      }\n      if (!token) {\n        self._failUnauthorized();\n        return;\n      }\n      self._token = token;\n      self._debug('connection token refreshed');\n\n      if (!self._isConnected()) {\n        return;\n      }\n\n      const cmd = {\n        refresh: { token: self._token }\n      };\n\n      self._call(cmd, false).then(resolveCtx => {\n        const result = resolveCtx.reply.refresh;\n        self._refreshResponse(result);\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        self._refreshError(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }).catch(function (e) {\n      if (!self._isConnected()) {\n        return;\n      }\n      if (e instanceof UnauthorizedError) {\n        self._failUnauthorized();\n        return;\n      }\n      self.emit('error', {\n        type: 'refreshToken',\n        error: {\n          code: errorCodes.clientRefreshToken,\n          message: e !== undefined ? e.toString() : ''\n        }\n      });\n      self._refreshTimeout = setTimeout(() => self._refresh(), self._getRefreshRetryDelay());\n    });\n  }\n\n  private _refreshError(err: any) {\n    if (err.code < 100 || err.temporary === true) {\n      this.emit('error', {\n        type: 'refresh',\n        error: err\n      });\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getRefreshRetryDelay());\n    } else {\n      this._disconnect(err.code, err.message, false);\n    }\n  }\n\n  private _getRefreshRetryDelay() {\n    return backoff(0, 5000, 10000);\n  }\n\n  private _refreshResponse(result: any) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (result.expires) {\n      this._client = result.client;\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n  }\n\n  private _removeSubscription(sub: Subscription | null) {\n    if (sub === null) {\n      return;\n    }\n    delete this._subs[sub.channel];\n  }\n\n  protected _unsubscribe(sub: Subscription) {\n    if (!this._transportIsOpen) {\n      return Promise.resolve();\n    }\n    const req = {\n      channel: sub.channel\n    };\n    const cmd = { unsubscribe: req };\n\n    const self = this;\n\n    const unsubscribePromise = new Promise<void>((resolve, _) => {\n      this._call(cmd, false).then(resolveCtx => {\n        resolve()\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        resolve()\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n        self._disconnect(connectingCodes.unsubscribeError, 'unsubscribe error', true);\n      });\n    });\n\n    return unsubscribePromise;\n  }\n\n  private _getSub(channel: string, id?: number) {\n    if (id && id > 0) {\n      for (const ch in this._subs) {\n        if (this._subs.hasOwnProperty(ch)) {\n          const sub = this._subs[ch];\n          // @ts-ignore \u2013 we are accessing private property for internal use\n          if (sub._id === id) {\n            return sub;\n          }\n        }\n      }\n      return null;\n    }\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  }\n\n  private _isServerSub(channel: string): boolean {\n    return this._serverSubs[channel] !== undefined;\n  }\n\n  private _sendSubscribeCommands(): any[] {\n    const commands: any[] = [];\n    for (const channel in this._subs) {\n      if (!this._subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = this._subs[channel];\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      if (sub._inflight === true) {\n        continue;\n      }\n      if (sub.state === SubscriptionState.Subscribing) {\n        // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n        const cmd = sub._subscribe();\n        if (cmd) {\n          commands.push(cmd);\n        }\n      }\n    }\n    return commands;\n  }\n\n  private _connectResponse(result: any) {\n    this._transportIsOpen = true;\n    this._transportWasOpen = true;\n    this._reconnectAttempts = 0;\n    this._refreshRequired = false;\n\n    if (this._isConnected()) {\n      return;\n    }\n\n    this._client = result.client;\n    this._setState(State.Connected);\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), ttlMilliseconds(result.ttl));\n    }\n\n    this._session = result.session;\n    this._node = result.node;\n\n    this.startBatching();\n    this._sendSubscribeCommands();\n    this.stopBatching();\n\n    const ctx: any = {\n      client: result.client,\n      transport: this._transport.subName()\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n\n    this.emit('connected', ctx);\n\n    this._resolvePromises();\n\n    this._processServerSubs(result.subs || {});\n\n    if (result.ping && result.ping > 0) {\n      this._serverPing = result.ping * 1000;\n      this._sendPong = result.pong === true;\n      this._waitServerPing();\n    } else {\n      this._serverPing = 0;\n    }\n  }\n\n  private _processServerSubs(subs: Record<string, any>) {\n    for (const channel in subs) {\n      if (!subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = subs[channel];\n      this._serverSubs[channel] = {\n        'offset': sub.offset,\n        'epoch': sub.epoch,\n        'recoverable': sub.recoverable || false\n      };\n      const subCtx = this._getSubscribeContext(channel, sub);\n      this.emit('subscribed', subCtx);\n    }\n\n    for (const channel in subs) {\n      if (!subs.hasOwnProperty(channel)) {\n        continue;\n      }\n      const sub = subs[channel];\n      if (sub.recovered) {\n        const pubs = sub.publications;\n        if (pubs && pubs.length > 0) {\n          for (const i in pubs) {\n            if (pubs.hasOwnProperty(i)) {\n              this._handlePublication(channel, pubs[i]);\n            }\n          }\n        }\n      }\n    }\n\n    for (const channel in this._serverSubs) {\n      if (!this._serverSubs.hasOwnProperty(channel)) {\n        continue;\n      }\n      if (!subs[channel]) {\n        this.emit('unsubscribed', { channel: channel });\n        delete this._serverSubs[channel];\n      }\n    }\n  }\n\n  private _clearRefreshTimeout() {\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n  }\n\n  private _clearReconnectTimeout() {\n    if (this._reconnectTimeout !== null) {\n      clearTimeout(this._reconnectTimeout);\n      this._reconnectTimeout = null;\n    }\n  }\n\n  private _clearServerPingTimeout() {\n    if (this._serverPingTimeout !== null) {\n      clearTimeout(this._serverPingTimeout);\n      this._serverPingTimeout = null;\n    }\n  }\n\n  private _waitServerPing() {\n    if (this._config.maxServerPingDelay === 0) {\n      return;\n    }\n    if (!this._isConnected()) {\n      return;\n    }\n    this._clearServerPingTimeout();\n    this._serverPingTimeout = setTimeout(() => {\n      if (!this._isConnected()) {\n        return;\n      }\n      this._disconnect(connectingCodes.noPing, 'no ping', true);\n    }, this._serverPing + this._config.maxServerPingDelay);\n  }\n\n  private _getSubscribeContext(channel: string, result: any): SubscribedContext {\n    const ctx: any = {\n      channel: channel,\n      positioned: false,\n      recoverable: false,\n      wasRecovering: false,\n      recovered: false,\n      hasRecoveredPublications: false,\n    };\n    if (result.recovered) {\n      ctx.recovered = true;\n    }\n    if (result.positioned) {\n      ctx.positioned = true;\n    }\n    if (result.recoverable) {\n      ctx.recoverable = true;\n    }\n    if (result.was_recovering) {\n      ctx.wasRecovering = true;\n    }\n    let epoch = '';\n    if ('epoch' in result) {\n      epoch = result.epoch;\n    }\n    let offset = 0;\n    if ('offset' in result) {\n      offset = result.offset;\n    }\n    if (ctx.positioned || ctx.recoverable) {\n      ctx.streamPosition = {\n        'offset': offset,\n        'epoch': epoch\n      };\n    }\n    if (Array.isArray(result.publications) && result.publications.length > 0) {\n      ctx.hasRecoveredPublications = true;\n    }\n    if (result.data) {\n      ctx.data = result.data;\n    }\n    return ctx;\n  }\n\n  private _handleReply(reply: any, next: any) {\n    const id = reply.id;\n    if (!(id in this._callbacks)) {\n      next();\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    clearTimeout(this._callbacks[id].timeout);\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback({ reply, next });\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        next();\n        return;\n      }\n      const error = {code: reply.error.code, message: reply.error.message || '', temporary: reply.error.temporary || false};\n      errback({ error, next });\n    }\n  }\n\n  private _handleJoin(channel: string, join: any, id?: number) {\n    const sub = this._getSub(channel, id);\n    if (!sub && channel) {\n      if (this._isServerSub(channel)) {\n        const ctx = { channel: channel, info: this._getJoinLeaveContext(join.info) };\n        this.emit('join', ctx);\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handleJoin(join);\n  }\n\n  private _handleLeave(channel: string, leave: any, id?: number) {\n    const sub = this._getSub(channel, id);\n    if (!sub && channel) {\n      if (this._isServerSub(channel)) {\n        const ctx = { channel: channel, info: this._getJoinLeaveContext(leave.info) };\n        this.emit('leave', ctx);\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handleLeave(leave);\n  }\n\n  private _handleUnsubscribe(channel: string, unsubscribe: any) {\n    const sub = this._getSub(channel, 0);\n    if (!sub && channel) {\n      if (this._isServerSub(channel)) {\n        delete this._serverSubs[channel];\n        this.emit('unsubscribed', { channel: channel });\n      }\n      return;\n    }\n    if (unsubscribe.code < 2500) {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      sub._setUnsubscribed(unsubscribe.code, unsubscribe.reason, false);\n    } else {\n      // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n      sub._setSubscribing(unsubscribe.code, unsubscribe.reason);\n    }\n  }\n\n  private _handleSubscribe(channel: string, sub: any) {\n    this._serverSubs[channel] = {\n      'offset': sub.offset,\n      'epoch': sub.epoch,\n      'recoverable': sub.recoverable || false\n    };\n    this.emit('subscribed', this._getSubscribeContext(channel, sub));\n  }\n\n  private _handleDisconnect(disconnect: any) {\n    const code = disconnect.code;\n    let reconnect = true;\n    if ((code >= 3500 && code < 4000) || (code >= 4500 && code < 5000)) {\n      reconnect = false;\n    }\n    this._disconnect(code, disconnect.reason, reconnect);\n  }\n\n  private _getPublicationContext(channel: string, pub: any) {\n    const ctx: any = {\n      channel: channel,\n      data: pub.data\n    };\n    if (pub.offset) {\n      ctx.offset = pub.offset;\n    }\n    if (pub.info) {\n      ctx.info = this._getJoinLeaveContext(pub.info);\n    }\n    if (pub.tags) {\n      ctx.tags = pub.tags;\n    }\n    return ctx;\n  }\n\n  private _getJoinLeaveContext(clientInfo: any) {\n    const info: any = {\n      client: clientInfo.client,\n      user: clientInfo.user\n    };\n    const connInfo = clientInfo['conn_info'];\n    if (connInfo) {\n      info.connInfo = connInfo;\n    }\n    const chanInfo = clientInfo['chan_info'];\n    if (chanInfo) {\n      info.chanInfo = chanInfo;\n    }\n    return info;\n  }\n\n  private _handlePublication(channel: string, pub: any, id?: number) {\n    const sub = this._getSub(channel, id);\n    if (!sub && channel) {\n      if (this._isServerSub(channel)) {\n        const ctx = this._getPublicationContext(channel, pub);\n        this.emit('publication', ctx);\n        if (pub.offset !== undefined) {\n          this._serverSubs[channel].offset = pub.offset;\n        }\n      }\n      return;\n    }\n    // @ts-ignore \u2013 we are hiding some symbols from public API autocompletion.\n    sub._handlePublication(pub);\n  }\n\n  private _handleMessage(message: any) {\n    this.emit('message', { data: message.data });\n  }\n\n  private _handleServerPing(next: any) {\n    if (this._sendPong) {\n      const cmd = {};\n      this._transportSendCommands([cmd]);\n    }\n    next();\n  }\n\n  private _handlePush(data: any, next: any) {\n    const channel = data.channel;\n    const id = data.id;\n    if (data.pub) {\n      this._handlePublication(channel, data.pub, id);\n    } else if (data.message) {\n      this._handleMessage(data.message);\n    } else if (data.join) {\n      this._handleJoin(channel, data.join, id);\n    } else if (data.leave) {\n      this._handleLeave(channel, data.leave, id);\n    } else if (data.unsubscribe) {\n      this._handleUnsubscribe(channel, data.unsubscribe);\n    } else if (data.subscribe) {\n      this._handleSubscribe(channel, data.subscribe);\n    } else if (data.disconnect) {\n      this._handleDisconnect(data.disconnect);\n    }\n    next();\n  }\n\n  private _flush() {\n    const commands = this._commands.slice(0);\n    this._commands = [];\n    this._transportSendCommands(commands);\n  }\n\n  private _createErrorObject(code: number, message: string, temporary?: boolean) {\n    const errObject: any = {\n      code: code,\n      message: message\n    };\n    if (temporary) {\n      errObject.temporary = true;\n    }\n    return errObject;\n  }\n\n  private _registerCall(id: number, callback: any, errback: any) {\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback,\n      timeout: null\n    };\n    this._callbacks[id].timeout = setTimeout(() => {\n      delete this._callbacks[id];\n      if (isFunction(errback)) {\n        errback({ error: this._createErrorObject(errorCodes.timeout, 'timeout') });\n      }\n    }, this._config.timeout);\n  }\n\n  private _addCommand(command: any) {\n    if (this._batching) {\n      this._commands.push(command);\n    } else {\n      this._transportSendCommands([command]);\n    }\n  }\n\n  private _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  private _nextTransportId() {\n    return ++this._transportId;\n  }\n\n  private _resolvePromises() {\n    for (const id in this._promises) {\n      if (!this._promises.hasOwnProperty(id)) {\n        continue;\n      }\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  }\n\n  private _rejectPromises(err: any) {\n    for (const id in this._promises) {\n      if (!this._promises.hasOwnProperty(id)) {\n        continue;\n      }\n      if (this._promises[id].timeout) {\n        clearTimeout(this._promises[id].timeout);\n      }\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  }\n}\n\nCentrifuge.SubscriptionState = SubscriptionState;\nCentrifuge.State = State\nCentrifuge.UnauthorizedError = UnauthorizedError;\n", "import { Writer, Reader } from 'protobufjs/minimal'\nimport { centrifugal } from './client_proto';\nimport { applyDelta } from './fossil';\n\nconst Command = centrifugal.centrifuge.protocol.Command;\nconst Reply = centrifugal.centrifuge.protocol.Reply;\nconst EmulationRequest = centrifugal.centrifuge.protocol.EmulationRequest;\n\n/** @internal */\nexport class ProtobufCodec {\n  name(): string {\n    return 'protobuf';\n  }\n\n  encodeEmulationRequest(req: centrifugal.centrifuge.protocol.IEmulationRequest): Uint8Array {\n    const writer = Writer.create();\n    EmulationRequest.encode(req, writer);\n    return writer.finish();\n  }\n\n  encodeCommands(commands: centrifugal.centrifuge.protocol.ICommand[]): Uint8Array {\n    const writer = Writer.create();\n    for (const command of commands) {\n      writer.fork();\n      Command.encodeDelimited(command, writer);\n    }\n    return writer.finish();\n  }\n\n  encodeReplies(replies: centrifugal.centrifuge.protocol.IReply[]): Uint8Array {\n    const writer = Writer.create();\n    for (const reply of replies) {\n      writer.fork();\n      Reply.encodeDelimited(reply, writer);\n    }\n    return writer.finish();\n  }\n\n  decodeReplies(data: ArrayBuffer | Uint8Array): centrifugal.centrifuge.protocol.Reply[] {\n    const replies: centrifugal.centrifuge.protocol.Reply[] = [];\n    const reader = Reader.create(new Uint8Array(data));\n    while (reader.pos < reader.len) {\n      const reply = Reply.decodeDelimited(reader);\n      replies.push(reply);\n    }\n    return replies;\n  }\n\n  decodeCommands(data: ArrayBuffer | Uint8Array): centrifugal.centrifuge.protocol.Command[] {\n    const commands: centrifugal.centrifuge.protocol.Command[] = [];\n    const reader = Reader.create(new Uint8Array(data));\n    while (reader.pos < reader.len) {\n      const reply = Command.decodeDelimited(reader);\n      commands.push(reply);\n    }\n    return commands;\n  }\n\n  decodeReply(data: ArrayBuffer | Uint8Array): { ok: true; pos: number } | { ok: false } {\n    const reader = Reader.create(new Uint8Array(data));\n    while (reader.pos < reader.len) {\n      Reply.decodeDelimited(reader);\n      return {\n        ok: true,\n        pos: reader.pos\n      };\n    }\n    return {\n      ok: false\n    };\n  }\n\n  applyDeltaIfNeeded(pub: centrifugal.centrifuge.protocol.IPublication, prevValue: Uint8Array): { newData: Uint8Array; newPrevValue: Uint8Array } {\n    let newData: Uint8Array, newPrevValue: Uint8Array;\n    if (pub.delta) {\n      // binary delta.\n      const valueArray = applyDelta(prevValue, pub.data!);\n      newData = new Uint8Array(valueArray)\n      newPrevValue = valueArray;\n    } else {\n      // full binary data.\n      newData = pub.data!;\n      newPrevValue = pub.data!;\n    }\n    return { newData, newPrevValue }\n  }\n}\n", "/*eslint-disable*/\nimport * as $protobuf from \"protobufjs/minimal\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\nexport const centrifugal = $root.centrifugal = (() => {\n\n    /**\n     * Namespace centrifugal.\n     * @exports centrifugal\n     * @namespace\n     */\n    const centrifugal = {};\n\n    centrifugal.centrifuge = (function() {\n\n        /**\n         * Namespace centrifuge.\n         * @memberof centrifugal\n         * @namespace\n         */\n        const centrifuge = {};\n\n        centrifuge.protocol = (function() {\n\n            /**\n             * Namespace protocol.\n             * @memberof centrifugal.centrifuge\n             * @namespace\n             */\n            const protocol = {};\n\n            protocol.Error = (function() {\n\n                /**\n                 * Properties of an Error.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IError\n                 * @property {number|null} [code] Error code\n                 * @property {string|null} [message] Error message\n                 * @property {boolean|null} [temporary] Error temporary\n                 */\n\n                /**\n                 * Constructs a new Error.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents an Error.\n                 * @implements IError\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IError=} [properties] Properties to set\n                 */\n                function Error(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Error code.\n                 * @member {number} code\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @instance\n                 */\n                Error.prototype.code = 0;\n\n                /**\n                 * Error message.\n                 * @member {string} message\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @instance\n                 */\n                Error.prototype.message = \"\";\n\n                /**\n                 * Error temporary.\n                 * @member {boolean} temporary\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @instance\n                 */\n                Error.prototype.temporary = false;\n\n                /**\n                 * Encodes the specified Error message. Does not implicitly {@link centrifugal.centrifuge.protocol.Error.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IError} message Error message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Error.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.code != null && Object.hasOwnProperty.call(message, \"code\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);\n                    if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);\n                    if (message.temporary != null && Object.hasOwnProperty.call(message, \"temporary\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.temporary);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Error message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Error.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IError} message Error message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Error.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes an Error message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Error} Error\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Error.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Error();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.code = reader.uint32();\n                                break;\n                            }\n                        case 2: {\n                                message.message = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.temporary = reader.bool();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes an Error message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Error} Error\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Error.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies an Error message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Error.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.code != null && message.hasOwnProperty(\"code\"))\n                        if (!$util.isInteger(message.code))\n                            return \"code: integer expected\";\n                    if (message.message != null && message.hasOwnProperty(\"message\"))\n                        if (!$util.isString(message.message))\n                            return \"message: string expected\";\n                    if (message.temporary != null && message.hasOwnProperty(\"temporary\"))\n                        if (typeof message.temporary !== \"boolean\")\n                            return \"temporary: boolean expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Error\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Error\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Error.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Error\";\n                };\n\n                return Error;\n            })();\n\n            protocol.EmulationRequest = (function() {\n\n                /**\n                 * Properties of an EmulationRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IEmulationRequest\n                 * @property {string|null} [node] EmulationRequest node\n                 * @property {string|null} [session] EmulationRequest session\n                 * @property {Uint8Array|null} [data] EmulationRequest data\n                 */\n\n                /**\n                 * Constructs a new EmulationRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents an EmulationRequest.\n                 * @implements IEmulationRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IEmulationRequest=} [properties] Properties to set\n                 */\n                function EmulationRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * EmulationRequest node.\n                 * @member {string} node\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @instance\n                 */\n                EmulationRequest.prototype.node = \"\";\n\n                /**\n                 * EmulationRequest session.\n                 * @member {string} session\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @instance\n                 */\n                EmulationRequest.prototype.session = \"\";\n\n                /**\n                 * EmulationRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @instance\n                 */\n                EmulationRequest.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * Encodes the specified EmulationRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.EmulationRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IEmulationRequest} message EmulationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EmulationRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.node != null && Object.hasOwnProperty.call(message, \"node\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.node);\n                    if (message.session != null && Object.hasOwnProperty.call(message, \"session\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.session);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified EmulationRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.EmulationRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IEmulationRequest} message EmulationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EmulationRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes an EmulationRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.EmulationRequest} EmulationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EmulationRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.EmulationRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.node = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.session = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes an EmulationRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.EmulationRequest} EmulationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EmulationRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies an EmulationRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                EmulationRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.node != null && message.hasOwnProperty(\"node\"))\n                        if (!$util.isString(message.node))\n                            return \"node: string expected\";\n                    if (message.session != null && message.hasOwnProperty(\"session\"))\n                        if (!$util.isString(message.session))\n                            return \"session: string expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for EmulationRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.EmulationRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                EmulationRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.EmulationRequest\";\n                };\n\n                return EmulationRequest;\n            })();\n\n            protocol.Command = (function() {\n\n                /**\n                 * Properties of a Command.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface ICommand\n                 * @property {number|null} [id] Command id\n                 * @property {centrifugal.centrifuge.protocol.IConnectRequest|null} [connect] Command connect\n                 * @property {centrifugal.centrifuge.protocol.ISubscribeRequest|null} [subscribe] Command subscribe\n                 * @property {centrifugal.centrifuge.protocol.IUnsubscribeRequest|null} [unsubscribe] Command unsubscribe\n                 * @property {centrifugal.centrifuge.protocol.IPublishRequest|null} [publish] Command publish\n                 * @property {centrifugal.centrifuge.protocol.IPresenceRequest|null} [presence] Command presence\n                 * @property {centrifugal.centrifuge.protocol.IPresenceStatsRequest|null} [presence_stats] Command presence_stats\n                 * @property {centrifugal.centrifuge.protocol.IHistoryRequest|null} [history] Command history\n                 * @property {centrifugal.centrifuge.protocol.IPingRequest|null} [ping] Command ping\n                 * @property {centrifugal.centrifuge.protocol.ISendRequest|null} [send] Command send\n                 * @property {centrifugal.centrifuge.protocol.IRPCRequest|null} [rpc] Command rpc\n                 * @property {centrifugal.centrifuge.protocol.IRefreshRequest|null} [refresh] Command refresh\n                 * @property {centrifugal.centrifuge.protocol.ISubRefreshRequest|null} [sub_refresh] Command sub_refresh\n                 */\n\n                /**\n                 * Constructs a new Command.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Command.\n                 * @implements ICommand\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.ICommand=} [properties] Properties to set\n                 */\n                function Command(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Command id.\n                 * @member {number} id\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.id = 0;\n\n                /**\n                 * Command connect.\n                 * @member {centrifugal.centrifuge.protocol.IConnectRequest|null|undefined} connect\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.connect = null;\n\n                /**\n                 * Command subscribe.\n                 * @member {centrifugal.centrifuge.protocol.ISubscribeRequest|null|undefined} subscribe\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.subscribe = null;\n\n                /**\n                 * Command unsubscribe.\n                 * @member {centrifugal.centrifuge.protocol.IUnsubscribeRequest|null|undefined} unsubscribe\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.unsubscribe = null;\n\n                /**\n                 * Command publish.\n                 * @member {centrifugal.centrifuge.protocol.IPublishRequest|null|undefined} publish\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.publish = null;\n\n                /**\n                 * Command presence.\n                 * @member {centrifugal.centrifuge.protocol.IPresenceRequest|null|undefined} presence\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.presence = null;\n\n                /**\n                 * Command presence_stats.\n                 * @member {centrifugal.centrifuge.protocol.IPresenceStatsRequest|null|undefined} presence_stats\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.presence_stats = null;\n\n                /**\n                 * Command history.\n                 * @member {centrifugal.centrifuge.protocol.IHistoryRequest|null|undefined} history\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.history = null;\n\n                /**\n                 * Command ping.\n                 * @member {centrifugal.centrifuge.protocol.IPingRequest|null|undefined} ping\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.ping = null;\n\n                /**\n                 * Command send.\n                 * @member {centrifugal.centrifuge.protocol.ISendRequest|null|undefined} send\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.send = null;\n\n                /**\n                 * Command rpc.\n                 * @member {centrifugal.centrifuge.protocol.IRPCRequest|null|undefined} rpc\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.rpc = null;\n\n                /**\n                 * Command refresh.\n                 * @member {centrifugal.centrifuge.protocol.IRefreshRequest|null|undefined} refresh\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.refresh = null;\n\n                /**\n                 * Command sub_refresh.\n                 * @member {centrifugal.centrifuge.protocol.ISubRefreshRequest|null|undefined} sub_refresh\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @instance\n                 */\n                Command.prototype.sub_refresh = null;\n\n                /**\n                 * Encodes the specified Command message. Does not implicitly {@link centrifugal.centrifuge.protocol.Command.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ICommand} message Command message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Command.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n                    if (message.connect != null && Object.hasOwnProperty.call(message, \"connect\"))\n                        $root.centrifugal.centrifuge.protocol.ConnectRequest.encode(message.connect, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.subscribe != null && Object.hasOwnProperty.call(message, \"subscribe\"))\n                        $root.centrifugal.centrifuge.protocol.SubscribeRequest.encode(message.subscribe, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.unsubscribe != null && Object.hasOwnProperty.call(message, \"unsubscribe\"))\n                        $root.centrifugal.centrifuge.protocol.UnsubscribeRequest.encode(message.unsubscribe, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.publish != null && Object.hasOwnProperty.call(message, \"publish\"))\n                        $root.centrifugal.centrifuge.protocol.PublishRequest.encode(message.publish, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.presence != null && Object.hasOwnProperty.call(message, \"presence\"))\n                        $root.centrifugal.centrifuge.protocol.PresenceRequest.encode(message.presence, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.presence_stats != null && Object.hasOwnProperty.call(message, \"presence_stats\"))\n                        $root.centrifugal.centrifuge.protocol.PresenceStatsRequest.encode(message.presence_stats, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                    if (message.history != null && Object.hasOwnProperty.call(message, \"history\"))\n                        $root.centrifugal.centrifuge.protocol.HistoryRequest.encode(message.history, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n                    if (message.ping != null && Object.hasOwnProperty.call(message, \"ping\"))\n                        $root.centrifugal.centrifuge.protocol.PingRequest.encode(message.ping, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                    if (message.send != null && Object.hasOwnProperty.call(message, \"send\"))\n                        $root.centrifugal.centrifuge.protocol.SendRequest.encode(message.send, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n                    if (message.rpc != null && Object.hasOwnProperty.call(message, \"rpc\"))\n                        $root.centrifugal.centrifuge.protocol.RPCRequest.encode(message.rpc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n                    if (message.refresh != null && Object.hasOwnProperty.call(message, \"refresh\"))\n                        $root.centrifugal.centrifuge.protocol.RefreshRequest.encode(message.refresh, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n                    if (message.sub_refresh != null && Object.hasOwnProperty.call(message, \"sub_refresh\"))\n                        $root.centrifugal.centrifuge.protocol.SubRefreshRequest.encode(message.sub_refresh, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Command message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Command.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ICommand} message Command message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Command.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Command message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Command} Command\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Command.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Command();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.id = reader.uint32();\n                                break;\n                            }\n                        case 4: {\n                                message.connect = $root.centrifugal.centrifuge.protocol.ConnectRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 5: {\n                                message.subscribe = $root.centrifugal.centrifuge.protocol.SubscribeRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 6: {\n                                message.unsubscribe = $root.centrifugal.centrifuge.protocol.UnsubscribeRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 7: {\n                                message.publish = $root.centrifugal.centrifuge.protocol.PublishRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 8: {\n                                message.presence = $root.centrifugal.centrifuge.protocol.PresenceRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 9: {\n                                message.presence_stats = $root.centrifugal.centrifuge.protocol.PresenceStatsRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 10: {\n                                message.history = $root.centrifugal.centrifuge.protocol.HistoryRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 11: {\n                                message.ping = $root.centrifugal.centrifuge.protocol.PingRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 12: {\n                                message.send = $root.centrifugal.centrifuge.protocol.SendRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 13: {\n                                message.rpc = $root.centrifugal.centrifuge.protocol.RPCRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 14: {\n                                message.refresh = $root.centrifugal.centrifuge.protocol.RefreshRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 15: {\n                                message.sub_refresh = $root.centrifugal.centrifuge.protocol.SubRefreshRequest.decode(reader, reader.uint32());\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Command message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Command} Command\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Command.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Command message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Command.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.id != null && message.hasOwnProperty(\"id\"))\n                        if (!$util.isInteger(message.id))\n                            return \"id: integer expected\";\n                    if (message.connect != null && message.hasOwnProperty(\"connect\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.ConnectRequest.verify(message.connect);\n                        if (error)\n                            return \"connect.\" + error;\n                    }\n                    if (message.subscribe != null && message.hasOwnProperty(\"subscribe\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.SubscribeRequest.verify(message.subscribe);\n                        if (error)\n                            return \"subscribe.\" + error;\n                    }\n                    if (message.unsubscribe != null && message.hasOwnProperty(\"unsubscribe\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.UnsubscribeRequest.verify(message.unsubscribe);\n                        if (error)\n                            return \"unsubscribe.\" + error;\n                    }\n                    if (message.publish != null && message.hasOwnProperty(\"publish\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.PublishRequest.verify(message.publish);\n                        if (error)\n                            return \"publish.\" + error;\n                    }\n                    if (message.presence != null && message.hasOwnProperty(\"presence\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.PresenceRequest.verify(message.presence);\n                        if (error)\n                            return \"presence.\" + error;\n                    }\n                    if (message.presence_stats != null && message.hasOwnProperty(\"presence_stats\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.PresenceStatsRequest.verify(message.presence_stats);\n                        if (error)\n                            return \"presence_stats.\" + error;\n                    }\n                    if (message.history != null && message.hasOwnProperty(\"history\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.HistoryRequest.verify(message.history);\n                        if (error)\n                            return \"history.\" + error;\n                    }\n                    if (message.ping != null && message.hasOwnProperty(\"ping\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.PingRequest.verify(message.ping);\n                        if (error)\n                            return \"ping.\" + error;\n                    }\n                    if (message.send != null && message.hasOwnProperty(\"send\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.SendRequest.verify(message.send);\n                        if (error)\n                            return \"send.\" + error;\n                    }\n                    if (message.rpc != null && message.hasOwnProperty(\"rpc\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.RPCRequest.verify(message.rpc);\n                        if (error)\n                            return \"rpc.\" + error;\n                    }\n                    if (message.refresh != null && message.hasOwnProperty(\"refresh\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.RefreshRequest.verify(message.refresh);\n                        if (error)\n                            return \"refresh.\" + error;\n                    }\n                    if (message.sub_refresh != null && message.hasOwnProperty(\"sub_refresh\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.SubRefreshRequest.verify(message.sub_refresh);\n                        if (error)\n                            return \"sub_refresh.\" + error;\n                    }\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Command\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Command\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Command.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Command\";\n                };\n\n                return Command;\n            })();\n\n            protocol.Reply = (function() {\n\n                /**\n                 * Properties of a Reply.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IReply\n                 * @property {number|null} [id] Reply id\n                 * @property {centrifugal.centrifuge.protocol.IError|null} [error] Reply error\n                 * @property {centrifugal.centrifuge.protocol.IPush|null} [push] Reply push\n                 * @property {centrifugal.centrifuge.protocol.IConnectResult|null} [connect] Reply connect\n                 * @property {centrifugal.centrifuge.protocol.ISubscribeResult|null} [subscribe] Reply subscribe\n                 * @property {centrifugal.centrifuge.protocol.IUnsubscribeResult|null} [unsubscribe] Reply unsubscribe\n                 * @property {centrifugal.centrifuge.protocol.IPublishResult|null} [publish] Reply publish\n                 * @property {centrifugal.centrifuge.protocol.IPresenceResult|null} [presence] Reply presence\n                 * @property {centrifugal.centrifuge.protocol.IPresenceStatsResult|null} [presence_stats] Reply presence_stats\n                 * @property {centrifugal.centrifuge.protocol.IHistoryResult|null} [history] Reply history\n                 * @property {centrifugal.centrifuge.protocol.IPingResult|null} [ping] Reply ping\n                 * @property {centrifugal.centrifuge.protocol.IRPCResult|null} [rpc] Reply rpc\n                 * @property {centrifugal.centrifuge.protocol.IRefreshResult|null} [refresh] Reply refresh\n                 * @property {centrifugal.centrifuge.protocol.ISubRefreshResult|null} [sub_refresh] Reply sub_refresh\n                 */\n\n                /**\n                 * Constructs a new Reply.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Reply.\n                 * @implements IReply\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IReply=} [properties] Properties to set\n                 */\n                function Reply(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Reply id.\n                 * @member {number} id\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.id = 0;\n\n                /**\n                 * Reply error.\n                 * @member {centrifugal.centrifuge.protocol.IError|null|undefined} error\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.error = null;\n\n                /**\n                 * Reply push.\n                 * @member {centrifugal.centrifuge.protocol.IPush|null|undefined} push\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.push = null;\n\n                /**\n                 * Reply connect.\n                 * @member {centrifugal.centrifuge.protocol.IConnectResult|null|undefined} connect\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.connect = null;\n\n                /**\n                 * Reply subscribe.\n                 * @member {centrifugal.centrifuge.protocol.ISubscribeResult|null|undefined} subscribe\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.subscribe = null;\n\n                /**\n                 * Reply unsubscribe.\n                 * @member {centrifugal.centrifuge.protocol.IUnsubscribeResult|null|undefined} unsubscribe\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.unsubscribe = null;\n\n                /**\n                 * Reply publish.\n                 * @member {centrifugal.centrifuge.protocol.IPublishResult|null|undefined} publish\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.publish = null;\n\n                /**\n                 * Reply presence.\n                 * @member {centrifugal.centrifuge.protocol.IPresenceResult|null|undefined} presence\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.presence = null;\n\n                /**\n                 * Reply presence_stats.\n                 * @member {centrifugal.centrifuge.protocol.IPresenceStatsResult|null|undefined} presence_stats\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.presence_stats = null;\n\n                /**\n                 * Reply history.\n                 * @member {centrifugal.centrifuge.protocol.IHistoryResult|null|undefined} history\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.history = null;\n\n                /**\n                 * Reply ping.\n                 * @member {centrifugal.centrifuge.protocol.IPingResult|null|undefined} ping\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.ping = null;\n\n                /**\n                 * Reply rpc.\n                 * @member {centrifugal.centrifuge.protocol.IRPCResult|null|undefined} rpc\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.rpc = null;\n\n                /**\n                 * Reply refresh.\n                 * @member {centrifugal.centrifuge.protocol.IRefreshResult|null|undefined} refresh\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.refresh = null;\n\n                /**\n                 * Reply sub_refresh.\n                 * @member {centrifugal.centrifuge.protocol.ISubRefreshResult|null|undefined} sub_refresh\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @instance\n                 */\n                Reply.prototype.sub_refresh = null;\n\n                /**\n                 * Encodes the specified Reply message. Does not implicitly {@link centrifugal.centrifuge.protocol.Reply.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IReply} message Reply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Reply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);\n                    if (message.error != null && Object.hasOwnProperty.call(message, \"error\"))\n                        $root.centrifugal.centrifuge.protocol.Error.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.push != null && Object.hasOwnProperty.call(message, \"push\"))\n                        $root.centrifugal.centrifuge.protocol.Push.encode(message.push, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.connect != null && Object.hasOwnProperty.call(message, \"connect\"))\n                        $root.centrifugal.centrifuge.protocol.ConnectResult.encode(message.connect, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.subscribe != null && Object.hasOwnProperty.call(message, \"subscribe\"))\n                        $root.centrifugal.centrifuge.protocol.SubscribeResult.encode(message.subscribe, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.unsubscribe != null && Object.hasOwnProperty.call(message, \"unsubscribe\"))\n                        $root.centrifugal.centrifuge.protocol.UnsubscribeResult.encode(message.unsubscribe, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.publish != null && Object.hasOwnProperty.call(message, \"publish\"))\n                        $root.centrifugal.centrifuge.protocol.PublishResult.encode(message.publish, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.presence != null && Object.hasOwnProperty.call(message, \"presence\"))\n                        $root.centrifugal.centrifuge.protocol.PresenceResult.encode(message.presence, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                    if (message.presence_stats != null && Object.hasOwnProperty.call(message, \"presence_stats\"))\n                        $root.centrifugal.centrifuge.protocol.PresenceStatsResult.encode(message.presence_stats, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n                    if (message.history != null && Object.hasOwnProperty.call(message, \"history\"))\n                        $root.centrifugal.centrifuge.protocol.HistoryResult.encode(message.history, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                    if (message.ping != null && Object.hasOwnProperty.call(message, \"ping\"))\n                        $root.centrifugal.centrifuge.protocol.PingResult.encode(message.ping, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n                    if (message.rpc != null && Object.hasOwnProperty.call(message, \"rpc\"))\n                        $root.centrifugal.centrifuge.protocol.RPCResult.encode(message.rpc, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n                    if (message.refresh != null && Object.hasOwnProperty.call(message, \"refresh\"))\n                        $root.centrifugal.centrifuge.protocol.RefreshResult.encode(message.refresh, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();\n                    if (message.sub_refresh != null && Object.hasOwnProperty.call(message, \"sub_refresh\"))\n                        $root.centrifugal.centrifuge.protocol.SubRefreshResult.encode(message.sub_refresh, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Reply message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Reply.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IReply} message Reply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Reply.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Reply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Reply} Reply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Reply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Reply();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.id = reader.uint32();\n                                break;\n                            }\n                        case 2: {\n                                message.error = $root.centrifugal.centrifuge.protocol.Error.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 4: {\n                                message.push = $root.centrifugal.centrifuge.protocol.Push.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 5: {\n                                message.connect = $root.centrifugal.centrifuge.protocol.ConnectResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 6: {\n                                message.subscribe = $root.centrifugal.centrifuge.protocol.SubscribeResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 7: {\n                                message.unsubscribe = $root.centrifugal.centrifuge.protocol.UnsubscribeResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 8: {\n                                message.publish = $root.centrifugal.centrifuge.protocol.PublishResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 9: {\n                                message.presence = $root.centrifugal.centrifuge.protocol.PresenceResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 10: {\n                                message.presence_stats = $root.centrifugal.centrifuge.protocol.PresenceStatsResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 11: {\n                                message.history = $root.centrifugal.centrifuge.protocol.HistoryResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 12: {\n                                message.ping = $root.centrifugal.centrifuge.protocol.PingResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 13: {\n                                message.rpc = $root.centrifugal.centrifuge.protocol.RPCResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 14: {\n                                message.refresh = $root.centrifugal.centrifuge.protocol.RefreshResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 15: {\n                                message.sub_refresh = $root.centrifugal.centrifuge.protocol.SubRefreshResult.decode(reader, reader.uint32());\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Reply message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Reply} Reply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Reply.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Reply message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Reply.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.id != null && message.hasOwnProperty(\"id\"))\n                        if (!$util.isInteger(message.id))\n                            return \"id: integer expected\";\n                    if (message.error != null && message.hasOwnProperty(\"error\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Error.verify(message.error);\n                        if (error)\n                            return \"error.\" + error;\n                    }\n                    if (message.push != null && message.hasOwnProperty(\"push\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Push.verify(message.push);\n                        if (error)\n                            return \"push.\" + error;\n                    }\n                    if (message.connect != null && message.hasOwnProperty(\"connect\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.ConnectResult.verify(message.connect);\n                        if (error)\n                            return \"connect.\" + error;\n                    }\n                    if (message.subscribe != null && message.hasOwnProperty(\"subscribe\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.SubscribeResult.verify(message.subscribe);\n                        if (error)\n                            return \"subscribe.\" + error;\n                    }\n                    if (message.unsubscribe != null && message.hasOwnProperty(\"unsubscribe\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.UnsubscribeResult.verify(message.unsubscribe);\n                        if (error)\n                            return \"unsubscribe.\" + error;\n                    }\n                    if (message.publish != null && message.hasOwnProperty(\"publish\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.PublishResult.verify(message.publish);\n                        if (error)\n                            return \"publish.\" + error;\n                    }\n                    if (message.presence != null && message.hasOwnProperty(\"presence\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.PresenceResult.verify(message.presence);\n                        if (error)\n                            return \"presence.\" + error;\n                    }\n                    if (message.presence_stats != null && message.hasOwnProperty(\"presence_stats\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.PresenceStatsResult.verify(message.presence_stats);\n                        if (error)\n                            return \"presence_stats.\" + error;\n                    }\n                    if (message.history != null && message.hasOwnProperty(\"history\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.HistoryResult.verify(message.history);\n                        if (error)\n                            return \"history.\" + error;\n                    }\n                    if (message.ping != null && message.hasOwnProperty(\"ping\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.PingResult.verify(message.ping);\n                        if (error)\n                            return \"ping.\" + error;\n                    }\n                    if (message.rpc != null && message.hasOwnProperty(\"rpc\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.RPCResult.verify(message.rpc);\n                        if (error)\n                            return \"rpc.\" + error;\n                    }\n                    if (message.refresh != null && message.hasOwnProperty(\"refresh\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.RefreshResult.verify(message.refresh);\n                        if (error)\n                            return \"refresh.\" + error;\n                    }\n                    if (message.sub_refresh != null && message.hasOwnProperty(\"sub_refresh\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.SubRefreshResult.verify(message.sub_refresh);\n                        if (error)\n                            return \"sub_refresh.\" + error;\n                    }\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Reply\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Reply\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Reply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Reply\";\n                };\n\n                return Reply;\n            })();\n\n            protocol.Push = (function() {\n\n                /**\n                 * Properties of a Push.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPush\n                 * @property {number|Long|null} [id] Push id\n                 * @property {string|null} [channel] Push channel\n                 * @property {centrifugal.centrifuge.protocol.IPublication|null} [pub] Push pub\n                 * @property {centrifugal.centrifuge.protocol.IJoin|null} [join] Push join\n                 * @property {centrifugal.centrifuge.protocol.ILeave|null} [leave] Push leave\n                 * @property {centrifugal.centrifuge.protocol.IUnsubscribe|null} [unsubscribe] Push unsubscribe\n                 * @property {centrifugal.centrifuge.protocol.IMessage|null} [message] Push message\n                 * @property {centrifugal.centrifuge.protocol.ISubscribe|null} [subscribe] Push subscribe\n                 * @property {centrifugal.centrifuge.protocol.IConnect|null} [connect] Push connect\n                 * @property {centrifugal.centrifuge.protocol.IDisconnect|null} [disconnect] Push disconnect\n                 * @property {centrifugal.centrifuge.protocol.IRefresh|null} [refresh] Push refresh\n                 */\n\n                /**\n                 * Constructs a new Push.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Push.\n                 * @implements IPush\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPush=} [properties] Properties to set\n                 */\n                function Push(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Push id.\n                 * @member {number|Long} id\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                /**\n                 * Push channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.channel = \"\";\n\n                /**\n                 * Push pub.\n                 * @member {centrifugal.centrifuge.protocol.IPublication|null|undefined} pub\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.pub = null;\n\n                /**\n                 * Push join.\n                 * @member {centrifugal.centrifuge.protocol.IJoin|null|undefined} join\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.join = null;\n\n                /**\n                 * Push leave.\n                 * @member {centrifugal.centrifuge.protocol.ILeave|null|undefined} leave\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.leave = null;\n\n                /**\n                 * Push unsubscribe.\n                 * @member {centrifugal.centrifuge.protocol.IUnsubscribe|null|undefined} unsubscribe\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.unsubscribe = null;\n\n                /**\n                 * Push message.\n                 * @member {centrifugal.centrifuge.protocol.IMessage|null|undefined} message\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.message = null;\n\n                /**\n                 * Push subscribe.\n                 * @member {centrifugal.centrifuge.protocol.ISubscribe|null|undefined} subscribe\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.subscribe = null;\n\n                /**\n                 * Push connect.\n                 * @member {centrifugal.centrifuge.protocol.IConnect|null|undefined} connect\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.connect = null;\n\n                /**\n                 * Push disconnect.\n                 * @member {centrifugal.centrifuge.protocol.IDisconnect|null|undefined} disconnect\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.disconnect = null;\n\n                /**\n                 * Push refresh.\n                 * @member {centrifugal.centrifuge.protocol.IRefresh|null|undefined} refresh\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @instance\n                 */\n                Push.prototype.refresh = null;\n\n                /**\n                 * Encodes the specified Push message. Does not implicitly {@link centrifugal.centrifuge.protocol.Push.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPush} message Push message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Push.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel);\n                    if (message.pub != null && Object.hasOwnProperty.call(message, \"pub\"))\n                        $root.centrifugal.centrifuge.protocol.Publication.encode(message.pub, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.join != null && Object.hasOwnProperty.call(message, \"join\"))\n                        $root.centrifugal.centrifuge.protocol.Join.encode(message.join, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.leave != null && Object.hasOwnProperty.call(message, \"leave\"))\n                        $root.centrifugal.centrifuge.protocol.Leave.encode(message.leave, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.unsubscribe != null && Object.hasOwnProperty.call(message, \"unsubscribe\"))\n                        $root.centrifugal.centrifuge.protocol.Unsubscribe.encode(message.unsubscribe, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                        $root.centrifugal.centrifuge.protocol.Message.encode(message.message, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.subscribe != null && Object.hasOwnProperty.call(message, \"subscribe\"))\n                        $root.centrifugal.centrifuge.protocol.Subscribe.encode(message.subscribe, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                    if (message.connect != null && Object.hasOwnProperty.call(message, \"connect\"))\n                        $root.centrifugal.centrifuge.protocol.Connect.encode(message.connect, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n                    if (message.disconnect != null && Object.hasOwnProperty.call(message, \"disconnect\"))\n                        $root.centrifugal.centrifuge.protocol.Disconnect.encode(message.disconnect, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                    if (message.refresh != null && Object.hasOwnProperty.call(message, \"refresh\"))\n                        $root.centrifugal.centrifuge.protocol.Refresh.encode(message.refresh, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Push message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Push.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPush} message Push message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Push.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Push message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Push} Push\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Push.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Push();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.id = reader.int64();\n                                break;\n                            }\n                        case 2: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        case 4: {\n                                message.pub = $root.centrifugal.centrifuge.protocol.Publication.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 5: {\n                                message.join = $root.centrifugal.centrifuge.protocol.Join.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 6: {\n                                message.leave = $root.centrifugal.centrifuge.protocol.Leave.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 7: {\n                                message.unsubscribe = $root.centrifugal.centrifuge.protocol.Unsubscribe.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 8: {\n                                message.message = $root.centrifugal.centrifuge.protocol.Message.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 9: {\n                                message.subscribe = $root.centrifugal.centrifuge.protocol.Subscribe.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 10: {\n                                message.connect = $root.centrifugal.centrifuge.protocol.Connect.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 11: {\n                                message.disconnect = $root.centrifugal.centrifuge.protocol.Disconnect.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 12: {\n                                message.refresh = $root.centrifugal.centrifuge.protocol.Refresh.decode(reader, reader.uint32());\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Push message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Push} Push\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Push.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Push message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Push.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.id != null && message.hasOwnProperty(\"id\"))\n                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))\n                            return \"id: integer|Long expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    if (message.pub != null && message.hasOwnProperty(\"pub\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Publication.verify(message.pub);\n                        if (error)\n                            return \"pub.\" + error;\n                    }\n                    if (message.join != null && message.hasOwnProperty(\"join\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Join.verify(message.join);\n                        if (error)\n                            return \"join.\" + error;\n                    }\n                    if (message.leave != null && message.hasOwnProperty(\"leave\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Leave.verify(message.leave);\n                        if (error)\n                            return \"leave.\" + error;\n                    }\n                    if (message.unsubscribe != null && message.hasOwnProperty(\"unsubscribe\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Unsubscribe.verify(message.unsubscribe);\n                        if (error)\n                            return \"unsubscribe.\" + error;\n                    }\n                    if (message.message != null && message.hasOwnProperty(\"message\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Message.verify(message.message);\n                        if (error)\n                            return \"message.\" + error;\n                    }\n                    if (message.subscribe != null && message.hasOwnProperty(\"subscribe\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Subscribe.verify(message.subscribe);\n                        if (error)\n                            return \"subscribe.\" + error;\n                    }\n                    if (message.connect != null && message.hasOwnProperty(\"connect\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Connect.verify(message.connect);\n                        if (error)\n                            return \"connect.\" + error;\n                    }\n                    if (message.disconnect != null && message.hasOwnProperty(\"disconnect\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Disconnect.verify(message.disconnect);\n                        if (error)\n                            return \"disconnect.\" + error;\n                    }\n                    if (message.refresh != null && message.hasOwnProperty(\"refresh\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.Refresh.verify(message.refresh);\n                        if (error)\n                            return \"refresh.\" + error;\n                    }\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Push\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Push\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Push.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Push\";\n                };\n\n                return Push;\n            })();\n\n            protocol.ClientInfo = (function() {\n\n                /**\n                 * Properties of a ClientInfo.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IClientInfo\n                 * @property {string|null} [user] ClientInfo user\n                 * @property {string|null} [client] ClientInfo client\n                 * @property {Uint8Array|null} [conn_info] ClientInfo conn_info\n                 * @property {Uint8Array|null} [chan_info] ClientInfo chan_info\n                 */\n\n                /**\n                 * Constructs a new ClientInfo.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a ClientInfo.\n                 * @implements IClientInfo\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IClientInfo=} [properties] Properties to set\n                 */\n                function ClientInfo(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * ClientInfo user.\n                 * @member {string} user\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @instance\n                 */\n                ClientInfo.prototype.user = \"\";\n\n                /**\n                 * ClientInfo client.\n                 * @member {string} client\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @instance\n                 */\n                ClientInfo.prototype.client = \"\";\n\n                /**\n                 * ClientInfo conn_info.\n                 * @member {Uint8Array} conn_info\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @instance\n                 */\n                ClientInfo.prototype.conn_info = $util.newBuffer([]);\n\n                /**\n                 * ClientInfo chan_info.\n                 * @member {Uint8Array} chan_info\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @instance\n                 */\n                ClientInfo.prototype.chan_info = $util.newBuffer([]);\n\n                /**\n                 * Encodes the specified ClientInfo message. Does not implicitly {@link centrifugal.centrifuge.protocol.ClientInfo.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IClientInfo} message ClientInfo message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ClientInfo.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.user != null && Object.hasOwnProperty.call(message, \"user\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);\n                    if (message.client != null && Object.hasOwnProperty.call(message, \"client\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.client);\n                    if (message.conn_info != null && Object.hasOwnProperty.call(message, \"conn_info\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.conn_info);\n                    if (message.chan_info != null && Object.hasOwnProperty.call(message, \"chan_info\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.chan_info);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified ClientInfo message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.ClientInfo.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IClientInfo} message ClientInfo message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ClientInfo.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a ClientInfo message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.ClientInfo} ClientInfo\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ClientInfo.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.ClientInfo();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.user = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.client = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.conn_info = reader.bytes();\n                                break;\n                            }\n                        case 4: {\n                                message.chan_info = reader.bytes();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a ClientInfo message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.ClientInfo} ClientInfo\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ClientInfo.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a ClientInfo message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                ClientInfo.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.user != null && message.hasOwnProperty(\"user\"))\n                        if (!$util.isString(message.user))\n                            return \"user: string expected\";\n                    if (message.client != null && message.hasOwnProperty(\"client\"))\n                        if (!$util.isString(message.client))\n                            return \"client: string expected\";\n                    if (message.conn_info != null && message.hasOwnProperty(\"conn_info\"))\n                        if (!(message.conn_info && typeof message.conn_info.length === \"number\" || $util.isString(message.conn_info)))\n                            return \"conn_info: buffer expected\";\n                    if (message.chan_info != null && message.hasOwnProperty(\"chan_info\"))\n                        if (!(message.chan_info && typeof message.chan_info.length === \"number\" || $util.isString(message.chan_info)))\n                            return \"chan_info: buffer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for ClientInfo\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.ClientInfo\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                ClientInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.ClientInfo\";\n                };\n\n                return ClientInfo;\n            })();\n\n            protocol.Publication = (function() {\n\n                /**\n                 * Properties of a Publication.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPublication\n                 * @property {Uint8Array|null} [data] Publication data\n                 * @property {centrifugal.centrifuge.protocol.IClientInfo|null} [info] Publication info\n                 * @property {number|Long|null} [offset] Publication offset\n                 * @property {Object.<string,string>|null} [tags] Publication tags\n                 * @property {boolean|null} [delta] Publication delta\n                 * @property {number|Long|null} [time] Publication time\n                 * @property {string|null} [channel] Publication channel\n                 */\n\n                /**\n                 * Constructs a new Publication.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Publication.\n                 * @implements IPublication\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPublication=} [properties] Properties to set\n                 */\n                function Publication(properties) {\n                    this.tags = {};\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Publication data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @instance\n                 */\n                Publication.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * Publication info.\n                 * @member {centrifugal.centrifuge.protocol.IClientInfo|null|undefined} info\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @instance\n                 */\n                Publication.prototype.info = null;\n\n                /**\n                 * Publication offset.\n                 * @member {number|Long} offset\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @instance\n                 */\n                Publication.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                /**\n                 * Publication tags.\n                 * @member {Object.<string,string>} tags\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @instance\n                 */\n                Publication.prototype.tags = $util.emptyObject;\n\n                /**\n                 * Publication delta.\n                 * @member {boolean} delta\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @instance\n                 */\n                Publication.prototype.delta = false;\n\n                /**\n                 * Publication time.\n                 * @member {number|Long} time\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @instance\n                 */\n                Publication.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                /**\n                 * Publication channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @instance\n                 */\n                Publication.prototype.channel = \"\";\n\n                /**\n                 * Encodes the specified Publication message. Does not implicitly {@link centrifugal.centrifuge.protocol.Publication.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPublication} message Publication message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Publication.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);\n                    if (message.info != null && Object.hasOwnProperty.call(message, \"info\"))\n                        $root.centrifugal.centrifuge.protocol.ClientInfo.encode(message.info, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.offset);\n                    if (message.tags != null && Object.hasOwnProperty.call(message, \"tags\"))\n                        for (let keys = Object.keys(message.tags), i = 0; i < keys.length; ++i)\n                            writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.tags[keys[i]]).ldelim();\n                    if (message.delta != null && Object.hasOwnProperty.call(message, \"delta\"))\n                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.delta);\n                    if (message.time != null && Object.hasOwnProperty.call(message, \"time\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).int64(message.time);\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.channel);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Publication message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Publication.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPublication} message Publication message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Publication.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Publication message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Publication} Publication\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Publication.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Publication(), key, value;\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 4: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        case 5: {\n                                message.info = $root.centrifugal.centrifuge.protocol.ClientInfo.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 6: {\n                                message.offset = reader.uint64();\n                                break;\n                            }\n                        case 7: {\n                                if (message.tags === $util.emptyObject)\n                                    message.tags = {};\n                                let end2 = reader.uint32() + reader.pos;\n                                key = \"\";\n                                value = \"\";\n                                while (reader.pos < end2) {\n                                    let tag2 = reader.uint32();\n                                    switch (tag2 >>> 3) {\n                                    case 1:\n                                        key = reader.string();\n                                        break;\n                                    case 2:\n                                        value = reader.string();\n                                        break;\n                                    default:\n                                        reader.skipType(tag2 & 7);\n                                        break;\n                                    }\n                                }\n                                message.tags[key] = value;\n                                break;\n                            }\n                        case 8: {\n                                message.delta = reader.bool();\n                                break;\n                            }\n                        case 9: {\n                                message.time = reader.int64();\n                                break;\n                            }\n                        case 10: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Publication message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Publication} Publication\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Publication.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Publication message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Publication.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    if (message.info != null && message.hasOwnProperty(\"info\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.ClientInfo.verify(message.info);\n                        if (error)\n                            return \"info.\" + error;\n                    }\n                    if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))\n                            return \"offset: integer|Long expected\";\n                    if (message.tags != null && message.hasOwnProperty(\"tags\")) {\n                        if (!$util.isObject(message.tags))\n                            return \"tags: object expected\";\n                        let key = Object.keys(message.tags);\n                        for (let i = 0; i < key.length; ++i)\n                            if (!$util.isString(message.tags[key[i]]))\n                                return \"tags: string{k:string} expected\";\n                    }\n                    if (message.delta != null && message.hasOwnProperty(\"delta\"))\n                        if (typeof message.delta !== \"boolean\")\n                            return \"delta: boolean expected\";\n                    if (message.time != null && message.hasOwnProperty(\"time\"))\n                        if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))\n                            return \"time: integer|Long expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Publication\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Publication\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Publication.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Publication\";\n                };\n\n                return Publication;\n            })();\n\n            protocol.Join = (function() {\n\n                /**\n                 * Properties of a Join.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IJoin\n                 * @property {centrifugal.centrifuge.protocol.IClientInfo|null} [info] Join info\n                 */\n\n                /**\n                 * Constructs a new Join.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Join.\n                 * @implements IJoin\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IJoin=} [properties] Properties to set\n                 */\n                function Join(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Join info.\n                 * @member {centrifugal.centrifuge.protocol.IClientInfo|null|undefined} info\n                 * @memberof centrifugal.centrifuge.protocol.Join\n                 * @instance\n                 */\n                Join.prototype.info = null;\n\n                /**\n                 * Encodes the specified Join message. Does not implicitly {@link centrifugal.centrifuge.protocol.Join.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Join\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IJoin} message Join message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Join.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.info != null && Object.hasOwnProperty.call(message, \"info\"))\n                        $root.centrifugal.centrifuge.protocol.ClientInfo.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Join message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Join.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Join\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IJoin} message Join message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Join.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Join message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Join\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Join} Join\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Join.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Join();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.info = $root.centrifugal.centrifuge.protocol.ClientInfo.decode(reader, reader.uint32());\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Join message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Join\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Join} Join\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Join.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Join message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Join\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Join.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.info != null && message.hasOwnProperty(\"info\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.ClientInfo.verify(message.info);\n                        if (error)\n                            return \"info.\" + error;\n                    }\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Join\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Join\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Join.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Join\";\n                };\n\n                return Join;\n            })();\n\n            protocol.Leave = (function() {\n\n                /**\n                 * Properties of a Leave.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface ILeave\n                 * @property {centrifugal.centrifuge.protocol.IClientInfo|null} [info] Leave info\n                 */\n\n                /**\n                 * Constructs a new Leave.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Leave.\n                 * @implements ILeave\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.ILeave=} [properties] Properties to set\n                 */\n                function Leave(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Leave info.\n                 * @member {centrifugal.centrifuge.protocol.IClientInfo|null|undefined} info\n                 * @memberof centrifugal.centrifuge.protocol.Leave\n                 * @instance\n                 */\n                Leave.prototype.info = null;\n\n                /**\n                 * Encodes the specified Leave message. Does not implicitly {@link centrifugal.centrifuge.protocol.Leave.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Leave\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ILeave} message Leave message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Leave.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.info != null && Object.hasOwnProperty.call(message, \"info\"))\n                        $root.centrifugal.centrifuge.protocol.ClientInfo.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Leave message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Leave.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Leave\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ILeave} message Leave message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Leave.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Leave message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Leave\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Leave} Leave\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Leave.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Leave();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.info = $root.centrifugal.centrifuge.protocol.ClientInfo.decode(reader, reader.uint32());\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Leave message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Leave\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Leave} Leave\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Leave.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Leave message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Leave\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Leave.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.info != null && message.hasOwnProperty(\"info\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.ClientInfo.verify(message.info);\n                        if (error)\n                            return \"info.\" + error;\n                    }\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Leave\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Leave\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Leave.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Leave\";\n                };\n\n                return Leave;\n            })();\n\n            protocol.Unsubscribe = (function() {\n\n                /**\n                 * Properties of an Unsubscribe.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IUnsubscribe\n                 * @property {number|null} [code] Unsubscribe code\n                 * @property {string|null} [reason] Unsubscribe reason\n                 */\n\n                /**\n                 * Constructs a new Unsubscribe.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents an Unsubscribe.\n                 * @implements IUnsubscribe\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribe=} [properties] Properties to set\n                 */\n                function Unsubscribe(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Unsubscribe code.\n                 * @member {number} code\n                 * @memberof centrifugal.centrifuge.protocol.Unsubscribe\n                 * @instance\n                 */\n                Unsubscribe.prototype.code = 0;\n\n                /**\n                 * Unsubscribe reason.\n                 * @member {string} reason\n                 * @memberof centrifugal.centrifuge.protocol.Unsubscribe\n                 * @instance\n                 */\n                Unsubscribe.prototype.reason = \"\";\n\n                /**\n                 * Encodes the specified Unsubscribe message. Does not implicitly {@link centrifugal.centrifuge.protocol.Unsubscribe.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Unsubscribe\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribe} message Unsubscribe message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Unsubscribe.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.code != null && Object.hasOwnProperty.call(message, \"code\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.code);\n                    if (message.reason != null && Object.hasOwnProperty.call(message, \"reason\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.reason);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Unsubscribe message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Unsubscribe.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Unsubscribe\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribe} message Unsubscribe message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Unsubscribe.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes an Unsubscribe message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Unsubscribe\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Unsubscribe} Unsubscribe\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Unsubscribe.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Unsubscribe();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 2: {\n                                message.code = reader.uint32();\n                                break;\n                            }\n                        case 3: {\n                                message.reason = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes an Unsubscribe message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Unsubscribe\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Unsubscribe} Unsubscribe\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Unsubscribe.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies an Unsubscribe message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Unsubscribe\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Unsubscribe.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.code != null && message.hasOwnProperty(\"code\"))\n                        if (!$util.isInteger(message.code))\n                            return \"code: integer expected\";\n                    if (message.reason != null && message.hasOwnProperty(\"reason\"))\n                        if (!$util.isString(message.reason))\n                            return \"reason: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Unsubscribe\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Unsubscribe\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Unsubscribe.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Unsubscribe\";\n                };\n\n                return Unsubscribe;\n            })();\n\n            protocol.Subscribe = (function() {\n\n                /**\n                 * Properties of a Subscribe.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface ISubscribe\n                 * @property {boolean|null} [recoverable] Subscribe recoverable\n                 * @property {string|null} [epoch] Subscribe epoch\n                 * @property {number|Long|null} [offset] Subscribe offset\n                 * @property {boolean|null} [positioned] Subscribe positioned\n                 * @property {Uint8Array|null} [data] Subscribe data\n                 */\n\n                /**\n                 * Constructs a new Subscribe.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Subscribe.\n                 * @implements ISubscribe\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.ISubscribe=} [properties] Properties to set\n                 */\n                function Subscribe(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Subscribe recoverable.\n                 * @member {boolean} recoverable\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @instance\n                 */\n                Subscribe.prototype.recoverable = false;\n\n                /**\n                 * Subscribe epoch.\n                 * @member {string} epoch\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @instance\n                 */\n                Subscribe.prototype.epoch = \"\";\n\n                /**\n                 * Subscribe offset.\n                 * @member {number|Long} offset\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @instance\n                 */\n                Subscribe.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                /**\n                 * Subscribe positioned.\n                 * @member {boolean} positioned\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @instance\n                 */\n                Subscribe.prototype.positioned = false;\n\n                /**\n                 * Subscribe data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @instance\n                 */\n                Subscribe.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * Encodes the specified Subscribe message. Does not implicitly {@link centrifugal.centrifuge.protocol.Subscribe.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubscribe} message Subscribe message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Subscribe.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.recoverable != null && Object.hasOwnProperty.call(message, \"recoverable\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.recoverable);\n                    if (message.epoch != null && Object.hasOwnProperty.call(message, \"epoch\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.epoch);\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.offset);\n                    if (message.positioned != null && Object.hasOwnProperty.call(message, \"positioned\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.positioned);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.data);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Subscribe message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Subscribe.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubscribe} message Subscribe message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Subscribe.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Subscribe message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Subscribe} Subscribe\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Subscribe.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Subscribe();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.recoverable = reader.bool();\n                                break;\n                            }\n                        case 4: {\n                                message.epoch = reader.string();\n                                break;\n                            }\n                        case 5: {\n                                message.offset = reader.uint64();\n                                break;\n                            }\n                        case 6: {\n                                message.positioned = reader.bool();\n                                break;\n                            }\n                        case 7: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Subscribe message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Subscribe} Subscribe\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Subscribe.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Subscribe message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Subscribe.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.recoverable != null && message.hasOwnProperty(\"recoverable\"))\n                        if (typeof message.recoverable !== \"boolean\")\n                            return \"recoverable: boolean expected\";\n                    if (message.epoch != null && message.hasOwnProperty(\"epoch\"))\n                        if (!$util.isString(message.epoch))\n                            return \"epoch: string expected\";\n                    if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))\n                            return \"offset: integer|Long expected\";\n                    if (message.positioned != null && message.hasOwnProperty(\"positioned\"))\n                        if (typeof message.positioned !== \"boolean\")\n                            return \"positioned: boolean expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Subscribe\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Subscribe\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Subscribe.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Subscribe\";\n                };\n\n                return Subscribe;\n            })();\n\n            protocol.Message = (function() {\n\n                /**\n                 * Properties of a Message.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IMessage\n                 * @property {Uint8Array|null} [data] Message data\n                 */\n\n                /**\n                 * Constructs a new Message.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Message.\n                 * @implements IMessage\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IMessage=} [properties] Properties to set\n                 */\n                function Message(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Message data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.Message\n                 * @instance\n                 */\n                Message.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * Encodes the specified Message message. Does not implicitly {@link centrifugal.centrifuge.protocol.Message.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Message\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IMessage} message Message message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Message.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Message message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Message.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Message\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IMessage} message Message message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Message.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Message message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Message\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Message} Message\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Message.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Message();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Message message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Message\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Message} Message\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Message.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Message message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Message\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Message.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Message\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Message\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Message.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Message\";\n                };\n\n                return Message;\n            })();\n\n            protocol.Connect = (function() {\n\n                /**\n                 * Properties of a Connect.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IConnect\n                 * @property {string|null} [client] Connect client\n                 * @property {string|null} [version] Connect version\n                 * @property {Uint8Array|null} [data] Connect data\n                 * @property {Object.<string,centrifugal.centrifuge.protocol.ISubscribeResult>|null} [subs] Connect subs\n                 * @property {boolean|null} [expires] Connect expires\n                 * @property {number|null} [ttl] Connect ttl\n                 * @property {number|null} [ping] Connect ping\n                 * @property {boolean|null} [pong] Connect pong\n                 * @property {string|null} [session] Connect session\n                 * @property {string|null} [node] Connect node\n                 * @property {number|Long|null} [time] Connect time\n                 */\n\n                /**\n                 * Constructs a new Connect.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Connect.\n                 * @implements IConnect\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IConnect=} [properties] Properties to set\n                 */\n                function Connect(properties) {\n                    this.subs = {};\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Connect client.\n                 * @member {string} client\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.client = \"\";\n\n                /**\n                 * Connect version.\n                 * @member {string} version\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.version = \"\";\n\n                /**\n                 * Connect data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * Connect subs.\n                 * @member {Object.<string,centrifugal.centrifuge.protocol.ISubscribeResult>} subs\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.subs = $util.emptyObject;\n\n                /**\n                 * Connect expires.\n                 * @member {boolean} expires\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.expires = false;\n\n                /**\n                 * Connect ttl.\n                 * @member {number} ttl\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.ttl = 0;\n\n                /**\n                 * Connect ping.\n                 * @member {number} ping\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.ping = 0;\n\n                /**\n                 * Connect pong.\n                 * @member {boolean} pong\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.pong = false;\n\n                /**\n                 * Connect session.\n                 * @member {string} session\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.session = \"\";\n\n                /**\n                 * Connect node.\n                 * @member {string} node\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.node = \"\";\n\n                /**\n                 * Connect time.\n                 * @member {number|Long} time\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @instance\n                 */\n                Connect.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                /**\n                 * Encodes the specified Connect message. Does not implicitly {@link centrifugal.centrifuge.protocol.Connect.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IConnect} message Connect message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Connect.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.client != null && Object.hasOwnProperty.call(message, \"client\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.client);\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);\n                    if (message.subs != null && Object.hasOwnProperty.call(message, \"subs\"))\n                        for (let keys = Object.keys(message.subs), i = 0; i < keys.length; ++i) {\n                            writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                            $root.centrifugal.centrifuge.protocol.SubscribeResult.encode(message.subs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                        }\n                    if (message.expires != null && Object.hasOwnProperty.call(message, \"expires\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.expires);\n                    if (message.ttl != null && Object.hasOwnProperty.call(message, \"ttl\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.ttl);\n                    if (message.ping != null && Object.hasOwnProperty.call(message, \"ping\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ping);\n                    if (message.pong != null && Object.hasOwnProperty.call(message, \"pong\"))\n                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.pong);\n                    if (message.session != null && Object.hasOwnProperty.call(message, \"session\"))\n                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.session);\n                    if (message.node != null && Object.hasOwnProperty.call(message, \"node\"))\n                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.node);\n                    if (message.time != null && Object.hasOwnProperty.call(message, \"time\"))\n                        writer.uint32(/* id 11, wireType 0 =*/88).int64(message.time);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Connect message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Connect.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IConnect} message Connect message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Connect.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Connect message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Connect} Connect\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Connect.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Connect(), key, value;\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.client = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.version = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        case 4: {\n                                if (message.subs === $util.emptyObject)\n                                    message.subs = {};\n                                let end2 = reader.uint32() + reader.pos;\n                                key = \"\";\n                                value = null;\n                                while (reader.pos < end2) {\n                                    let tag2 = reader.uint32();\n                                    switch (tag2 >>> 3) {\n                                    case 1:\n                                        key = reader.string();\n                                        break;\n                                    case 2:\n                                        value = $root.centrifugal.centrifuge.protocol.SubscribeResult.decode(reader, reader.uint32());\n                                        break;\n                                    default:\n                                        reader.skipType(tag2 & 7);\n                                        break;\n                                    }\n                                }\n                                message.subs[key] = value;\n                                break;\n                            }\n                        case 5: {\n                                message.expires = reader.bool();\n                                break;\n                            }\n                        case 6: {\n                                message.ttl = reader.uint32();\n                                break;\n                            }\n                        case 7: {\n                                message.ping = reader.uint32();\n                                break;\n                            }\n                        case 8: {\n                                message.pong = reader.bool();\n                                break;\n                            }\n                        case 9: {\n                                message.session = reader.string();\n                                break;\n                            }\n                        case 10: {\n                                message.node = reader.string();\n                                break;\n                            }\n                        case 11: {\n                                message.time = reader.int64();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Connect message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Connect} Connect\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Connect.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Connect message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Connect.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.client != null && message.hasOwnProperty(\"client\"))\n                        if (!$util.isString(message.client))\n                            return \"client: string expected\";\n                    if (message.version != null && message.hasOwnProperty(\"version\"))\n                        if (!$util.isString(message.version))\n                            return \"version: string expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    if (message.subs != null && message.hasOwnProperty(\"subs\")) {\n                        if (!$util.isObject(message.subs))\n                            return \"subs: object expected\";\n                        let key = Object.keys(message.subs);\n                        for (let i = 0; i < key.length; ++i) {\n                            let error = $root.centrifugal.centrifuge.protocol.SubscribeResult.verify(message.subs[key[i]]);\n                            if (error)\n                                return \"subs.\" + error;\n                        }\n                    }\n                    if (message.expires != null && message.hasOwnProperty(\"expires\"))\n                        if (typeof message.expires !== \"boolean\")\n                            return \"expires: boolean expected\";\n                    if (message.ttl != null && message.hasOwnProperty(\"ttl\"))\n                        if (!$util.isInteger(message.ttl))\n                            return \"ttl: integer expected\";\n                    if (message.ping != null && message.hasOwnProperty(\"ping\"))\n                        if (!$util.isInteger(message.ping))\n                            return \"ping: integer expected\";\n                    if (message.pong != null && message.hasOwnProperty(\"pong\"))\n                        if (typeof message.pong !== \"boolean\")\n                            return \"pong: boolean expected\";\n                    if (message.session != null && message.hasOwnProperty(\"session\"))\n                        if (!$util.isString(message.session))\n                            return \"session: string expected\";\n                    if (message.node != null && message.hasOwnProperty(\"node\"))\n                        if (!$util.isString(message.node))\n                            return \"node: string expected\";\n                    if (message.time != null && message.hasOwnProperty(\"time\"))\n                        if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))\n                            return \"time: integer|Long expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Connect\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Connect\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Connect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Connect\";\n                };\n\n                return Connect;\n            })();\n\n            protocol.Disconnect = (function() {\n\n                /**\n                 * Properties of a Disconnect.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IDisconnect\n                 * @property {number|null} [code] Disconnect code\n                 * @property {string|null} [reason] Disconnect reason\n                 * @property {boolean|null} [reconnect] Disconnect reconnect\n                 */\n\n                /**\n                 * Constructs a new Disconnect.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Disconnect.\n                 * @implements IDisconnect\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IDisconnect=} [properties] Properties to set\n                 */\n                function Disconnect(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Disconnect code.\n                 * @member {number} code\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @instance\n                 */\n                Disconnect.prototype.code = 0;\n\n                /**\n                 * Disconnect reason.\n                 * @member {string} reason\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @instance\n                 */\n                Disconnect.prototype.reason = \"\";\n\n                /**\n                 * Disconnect reconnect.\n                 * @member {boolean} reconnect\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @instance\n                 */\n                Disconnect.prototype.reconnect = false;\n\n                /**\n                 * Encodes the specified Disconnect message. Does not implicitly {@link centrifugal.centrifuge.protocol.Disconnect.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IDisconnect} message Disconnect message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Disconnect.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.code != null && Object.hasOwnProperty.call(message, \"code\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.code);\n                    if (message.reason != null && Object.hasOwnProperty.call(message, \"reason\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.reason);\n                    if (message.reconnect != null && Object.hasOwnProperty.call(message, \"reconnect\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.reconnect);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Disconnect message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Disconnect.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IDisconnect} message Disconnect message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Disconnect.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Disconnect message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Disconnect} Disconnect\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Disconnect.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Disconnect();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.code = reader.uint32();\n                                break;\n                            }\n                        case 2: {\n                                message.reason = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.reconnect = reader.bool();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Disconnect message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Disconnect} Disconnect\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Disconnect.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Disconnect message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Disconnect.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.code != null && message.hasOwnProperty(\"code\"))\n                        if (!$util.isInteger(message.code))\n                            return \"code: integer expected\";\n                    if (message.reason != null && message.hasOwnProperty(\"reason\"))\n                        if (!$util.isString(message.reason))\n                            return \"reason: string expected\";\n                    if (message.reconnect != null && message.hasOwnProperty(\"reconnect\"))\n                        if (typeof message.reconnect !== \"boolean\")\n                            return \"reconnect: boolean expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Disconnect\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Disconnect\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Disconnect.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Disconnect\";\n                };\n\n                return Disconnect;\n            })();\n\n            protocol.Refresh = (function() {\n\n                /**\n                 * Properties of a Refresh.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IRefresh\n                 * @property {boolean|null} [expires] Refresh expires\n                 * @property {number|null} [ttl] Refresh ttl\n                 */\n\n                /**\n                 * Constructs a new Refresh.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a Refresh.\n                 * @implements IRefresh\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IRefresh=} [properties] Properties to set\n                 */\n                function Refresh(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Refresh expires.\n                 * @member {boolean} expires\n                 * @memberof centrifugal.centrifuge.protocol.Refresh\n                 * @instance\n                 */\n                Refresh.prototype.expires = false;\n\n                /**\n                 * Refresh ttl.\n                 * @member {number} ttl\n                 * @memberof centrifugal.centrifuge.protocol.Refresh\n                 * @instance\n                 */\n                Refresh.prototype.ttl = 0;\n\n                /**\n                 * Encodes the specified Refresh message. Does not implicitly {@link centrifugal.centrifuge.protocol.Refresh.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.Refresh\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRefresh} message Refresh message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Refresh.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.expires != null && Object.hasOwnProperty.call(message, \"expires\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.expires);\n                    if (message.ttl != null && Object.hasOwnProperty.call(message, \"ttl\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ttl);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified Refresh message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.Refresh.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Refresh\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRefresh} message Refresh message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Refresh.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a Refresh message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.Refresh\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.Refresh} Refresh\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Refresh.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.Refresh();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.expires = reader.bool();\n                                break;\n                            }\n                        case 2: {\n                                message.ttl = reader.uint32();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a Refresh message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.Refresh\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.Refresh} Refresh\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Refresh.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a Refresh message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.Refresh\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                Refresh.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.expires != null && message.hasOwnProperty(\"expires\"))\n                        if (typeof message.expires !== \"boolean\")\n                            return \"expires: boolean expected\";\n                    if (message.ttl != null && message.hasOwnProperty(\"ttl\"))\n                        if (!$util.isInteger(message.ttl))\n                            return \"ttl: integer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for Refresh\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.Refresh\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                Refresh.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.Refresh\";\n                };\n\n                return Refresh;\n            })();\n\n            protocol.ConnectRequest = (function() {\n\n                /**\n                 * Properties of a ConnectRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IConnectRequest\n                 * @property {string|null} [token] ConnectRequest token\n                 * @property {Uint8Array|null} [data] ConnectRequest data\n                 * @property {Object.<string,centrifugal.centrifuge.protocol.ISubscribeRequest>|null} [subs] ConnectRequest subs\n                 * @property {string|null} [name] ConnectRequest name\n                 * @property {string|null} [version] ConnectRequest version\n                 * @property {Object.<string,string>|null} [headers] ConnectRequest headers\n                 * @property {number|Long|null} [flag] ConnectRequest flag\n                 */\n\n                /**\n                 * Constructs a new ConnectRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a ConnectRequest.\n                 * @implements IConnectRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IConnectRequest=} [properties] Properties to set\n                 */\n                function ConnectRequest(properties) {\n                    this.subs = {};\n                    this.headers = {};\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * ConnectRequest token.\n                 * @member {string} token\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @instance\n                 */\n                ConnectRequest.prototype.token = \"\";\n\n                /**\n                 * ConnectRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @instance\n                 */\n                ConnectRequest.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * ConnectRequest subs.\n                 * @member {Object.<string,centrifugal.centrifuge.protocol.ISubscribeRequest>} subs\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @instance\n                 */\n                ConnectRequest.prototype.subs = $util.emptyObject;\n\n                /**\n                 * ConnectRequest name.\n                 * @member {string} name\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @instance\n                 */\n                ConnectRequest.prototype.name = \"\";\n\n                /**\n                 * ConnectRequest version.\n                 * @member {string} version\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @instance\n                 */\n                ConnectRequest.prototype.version = \"\";\n\n                /**\n                 * ConnectRequest headers.\n                 * @member {Object.<string,string>} headers\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @instance\n                 */\n                ConnectRequest.prototype.headers = $util.emptyObject;\n\n                /**\n                 * ConnectRequest flag.\n                 * @member {number|Long} flag\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @instance\n                 */\n                ConnectRequest.prototype.flag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                /**\n                 * Encodes the specified ConnectRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.ConnectRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IConnectRequest} message ConnectRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ConnectRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.token != null && Object.hasOwnProperty.call(message, \"token\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);\n                    if (message.subs != null && Object.hasOwnProperty.call(message, \"subs\"))\n                        for (let keys = Object.keys(message.subs), i = 0; i < keys.length; ++i) {\n                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                            $root.centrifugal.centrifuge.protocol.SubscribeRequest.encode(message.subs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                        }\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.version);\n                    if (message.headers != null && Object.hasOwnProperty.call(message, \"headers\"))\n                        for (let keys = Object.keys(message.headers), i = 0; i < keys.length; ++i)\n                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.headers[keys[i]]).ldelim();\n                    if (message.flag != null && Object.hasOwnProperty.call(message, \"flag\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).int64(message.flag);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified ConnectRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.ConnectRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IConnectRequest} message ConnectRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ConnectRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a ConnectRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.ConnectRequest} ConnectRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ConnectRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.ConnectRequest(), key, value;\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.token = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        case 3: {\n                                if (message.subs === $util.emptyObject)\n                                    message.subs = {};\n                                let end2 = reader.uint32() + reader.pos;\n                                key = \"\";\n                                value = null;\n                                while (reader.pos < end2) {\n                                    let tag2 = reader.uint32();\n                                    switch (tag2 >>> 3) {\n                                    case 1:\n                                        key = reader.string();\n                                        break;\n                                    case 2:\n                                        value = $root.centrifugal.centrifuge.protocol.SubscribeRequest.decode(reader, reader.uint32());\n                                        break;\n                                    default:\n                                        reader.skipType(tag2 & 7);\n                                        break;\n                                    }\n                                }\n                                message.subs[key] = value;\n                                break;\n                            }\n                        case 4: {\n                                message.name = reader.string();\n                                break;\n                            }\n                        case 5: {\n                                message.version = reader.string();\n                                break;\n                            }\n                        case 6: {\n                                if (message.headers === $util.emptyObject)\n                                    message.headers = {};\n                                let end2 = reader.uint32() + reader.pos;\n                                key = \"\";\n                                value = \"\";\n                                while (reader.pos < end2) {\n                                    let tag2 = reader.uint32();\n                                    switch (tag2 >>> 3) {\n                                    case 1:\n                                        key = reader.string();\n                                        break;\n                                    case 2:\n                                        value = reader.string();\n                                        break;\n                                    default:\n                                        reader.skipType(tag2 & 7);\n                                        break;\n                                    }\n                                }\n                                message.headers[key] = value;\n                                break;\n                            }\n                        case 7: {\n                                message.flag = reader.int64();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a ConnectRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.ConnectRequest} ConnectRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ConnectRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a ConnectRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                ConnectRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.token != null && message.hasOwnProperty(\"token\"))\n                        if (!$util.isString(message.token))\n                            return \"token: string expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    if (message.subs != null && message.hasOwnProperty(\"subs\")) {\n                        if (!$util.isObject(message.subs))\n                            return \"subs: object expected\";\n                        let key = Object.keys(message.subs);\n                        for (let i = 0; i < key.length; ++i) {\n                            let error = $root.centrifugal.centrifuge.protocol.SubscribeRequest.verify(message.subs[key[i]]);\n                            if (error)\n                                return \"subs.\" + error;\n                        }\n                    }\n                    if (message.name != null && message.hasOwnProperty(\"name\"))\n                        if (!$util.isString(message.name))\n                            return \"name: string expected\";\n                    if (message.version != null && message.hasOwnProperty(\"version\"))\n                        if (!$util.isString(message.version))\n                            return \"version: string expected\";\n                    if (message.headers != null && message.hasOwnProperty(\"headers\")) {\n                        if (!$util.isObject(message.headers))\n                            return \"headers: object expected\";\n                        let key = Object.keys(message.headers);\n                        for (let i = 0; i < key.length; ++i)\n                            if (!$util.isString(message.headers[key[i]]))\n                                return \"headers: string{k:string} expected\";\n                    }\n                    if (message.flag != null && message.hasOwnProperty(\"flag\"))\n                        if (!$util.isInteger(message.flag) && !(message.flag && $util.isInteger(message.flag.low) && $util.isInteger(message.flag.high)))\n                            return \"flag: integer|Long expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for ConnectRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.ConnectRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                ConnectRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.ConnectRequest\";\n                };\n\n                return ConnectRequest;\n            })();\n\n            protocol.ConnectResult = (function() {\n\n                /**\n                 * Properties of a ConnectResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IConnectResult\n                 * @property {string|null} [client] ConnectResult client\n                 * @property {string|null} [version] ConnectResult version\n                 * @property {boolean|null} [expires] ConnectResult expires\n                 * @property {number|null} [ttl] ConnectResult ttl\n                 * @property {Uint8Array|null} [data] ConnectResult data\n                 * @property {Object.<string,centrifugal.centrifuge.protocol.ISubscribeResult>|null} [subs] ConnectResult subs\n                 * @property {number|null} [ping] ConnectResult ping\n                 * @property {boolean|null} [pong] ConnectResult pong\n                 * @property {string|null} [session] ConnectResult session\n                 * @property {string|null} [node] ConnectResult node\n                 * @property {number|Long|null} [time] ConnectResult time\n                 */\n\n                /**\n                 * Constructs a new ConnectResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a ConnectResult.\n                 * @implements IConnectResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IConnectResult=} [properties] Properties to set\n                 */\n                function ConnectResult(properties) {\n                    this.subs = {};\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * ConnectResult client.\n                 * @member {string} client\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.client = \"\";\n\n                /**\n                 * ConnectResult version.\n                 * @member {string} version\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.version = \"\";\n\n                /**\n                 * ConnectResult expires.\n                 * @member {boolean} expires\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.expires = false;\n\n                /**\n                 * ConnectResult ttl.\n                 * @member {number} ttl\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.ttl = 0;\n\n                /**\n                 * ConnectResult data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * ConnectResult subs.\n                 * @member {Object.<string,centrifugal.centrifuge.protocol.ISubscribeResult>} subs\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.subs = $util.emptyObject;\n\n                /**\n                 * ConnectResult ping.\n                 * @member {number} ping\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.ping = 0;\n\n                /**\n                 * ConnectResult pong.\n                 * @member {boolean} pong\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.pong = false;\n\n                /**\n                 * ConnectResult session.\n                 * @member {string} session\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.session = \"\";\n\n                /**\n                 * ConnectResult node.\n                 * @member {string} node\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.node = \"\";\n\n                /**\n                 * ConnectResult time.\n                 * @member {number|Long} time\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @instance\n                 */\n                ConnectResult.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                /**\n                 * Encodes the specified ConnectResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.ConnectResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IConnectResult} message ConnectResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ConnectResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.client != null && Object.hasOwnProperty.call(message, \"client\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.client);\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);\n                    if (message.expires != null && Object.hasOwnProperty.call(message, \"expires\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.expires);\n                    if (message.ttl != null && Object.hasOwnProperty.call(message, \"ttl\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.ttl);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.data);\n                    if (message.subs != null && Object.hasOwnProperty.call(message, \"subs\"))\n                        for (let keys = Object.keys(message.subs), i = 0; i < keys.length; ++i) {\n                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                            $root.centrifugal.centrifuge.protocol.SubscribeResult.encode(message.subs[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                        }\n                    if (message.ping != null && Object.hasOwnProperty.call(message, \"ping\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ping);\n                    if (message.pong != null && Object.hasOwnProperty.call(message, \"pong\"))\n                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.pong);\n                    if (message.session != null && Object.hasOwnProperty.call(message, \"session\"))\n                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.session);\n                    if (message.node != null && Object.hasOwnProperty.call(message, \"node\"))\n                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.node);\n                    if (message.time != null && Object.hasOwnProperty.call(message, \"time\"))\n                        writer.uint32(/* id 11, wireType 0 =*/88).int64(message.time);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified ConnectResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.ConnectResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IConnectResult} message ConnectResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ConnectResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a ConnectResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.ConnectResult} ConnectResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ConnectResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.ConnectResult(), key, value;\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.client = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.version = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.expires = reader.bool();\n                                break;\n                            }\n                        case 4: {\n                                message.ttl = reader.uint32();\n                                break;\n                            }\n                        case 5: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        case 6: {\n                                if (message.subs === $util.emptyObject)\n                                    message.subs = {};\n                                let end2 = reader.uint32() + reader.pos;\n                                key = \"\";\n                                value = null;\n                                while (reader.pos < end2) {\n                                    let tag2 = reader.uint32();\n                                    switch (tag2 >>> 3) {\n                                    case 1:\n                                        key = reader.string();\n                                        break;\n                                    case 2:\n                                        value = $root.centrifugal.centrifuge.protocol.SubscribeResult.decode(reader, reader.uint32());\n                                        break;\n                                    default:\n                                        reader.skipType(tag2 & 7);\n                                        break;\n                                    }\n                                }\n                                message.subs[key] = value;\n                                break;\n                            }\n                        case 7: {\n                                message.ping = reader.uint32();\n                                break;\n                            }\n                        case 8: {\n                                message.pong = reader.bool();\n                                break;\n                            }\n                        case 9: {\n                                message.session = reader.string();\n                                break;\n                            }\n                        case 10: {\n                                message.node = reader.string();\n                                break;\n                            }\n                        case 11: {\n                                message.time = reader.int64();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a ConnectResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.ConnectResult} ConnectResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ConnectResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a ConnectResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                ConnectResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.client != null && message.hasOwnProperty(\"client\"))\n                        if (!$util.isString(message.client))\n                            return \"client: string expected\";\n                    if (message.version != null && message.hasOwnProperty(\"version\"))\n                        if (!$util.isString(message.version))\n                            return \"version: string expected\";\n                    if (message.expires != null && message.hasOwnProperty(\"expires\"))\n                        if (typeof message.expires !== \"boolean\")\n                            return \"expires: boolean expected\";\n                    if (message.ttl != null && message.hasOwnProperty(\"ttl\"))\n                        if (!$util.isInteger(message.ttl))\n                            return \"ttl: integer expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    if (message.subs != null && message.hasOwnProperty(\"subs\")) {\n                        if (!$util.isObject(message.subs))\n                            return \"subs: object expected\";\n                        let key = Object.keys(message.subs);\n                        for (let i = 0; i < key.length; ++i) {\n                            let error = $root.centrifugal.centrifuge.protocol.SubscribeResult.verify(message.subs[key[i]]);\n                            if (error)\n                                return \"subs.\" + error;\n                        }\n                    }\n                    if (message.ping != null && message.hasOwnProperty(\"ping\"))\n                        if (!$util.isInteger(message.ping))\n                            return \"ping: integer expected\";\n                    if (message.pong != null && message.hasOwnProperty(\"pong\"))\n                        if (typeof message.pong !== \"boolean\")\n                            return \"pong: boolean expected\";\n                    if (message.session != null && message.hasOwnProperty(\"session\"))\n                        if (!$util.isString(message.session))\n                            return \"session: string expected\";\n                    if (message.node != null && message.hasOwnProperty(\"node\"))\n                        if (!$util.isString(message.node))\n                            return \"node: string expected\";\n                    if (message.time != null && message.hasOwnProperty(\"time\"))\n                        if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))\n                            return \"time: integer|Long expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for ConnectResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.ConnectResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                ConnectResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.ConnectResult\";\n                };\n\n                return ConnectResult;\n            })();\n\n            protocol.RefreshRequest = (function() {\n\n                /**\n                 * Properties of a RefreshRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IRefreshRequest\n                 * @property {string|null} [token] RefreshRequest token\n                 */\n\n                /**\n                 * Constructs a new RefreshRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a RefreshRequest.\n                 * @implements IRefreshRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IRefreshRequest=} [properties] Properties to set\n                 */\n                function RefreshRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * RefreshRequest token.\n                 * @member {string} token\n                 * @memberof centrifugal.centrifuge.protocol.RefreshRequest\n                 * @instance\n                 */\n                RefreshRequest.prototype.token = \"\";\n\n                /**\n                 * Encodes the specified RefreshRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.RefreshRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.RefreshRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRefreshRequest} message RefreshRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                RefreshRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.token != null && Object.hasOwnProperty.call(message, \"token\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.token);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified RefreshRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.RefreshRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.RefreshRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRefreshRequest} message RefreshRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                RefreshRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a RefreshRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.RefreshRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.RefreshRequest} RefreshRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                RefreshRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.RefreshRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.token = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a RefreshRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.RefreshRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.RefreshRequest} RefreshRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                RefreshRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a RefreshRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.RefreshRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                RefreshRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.token != null && message.hasOwnProperty(\"token\"))\n                        if (!$util.isString(message.token))\n                            return \"token: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for RefreshRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.RefreshRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                RefreshRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.RefreshRequest\";\n                };\n\n                return RefreshRequest;\n            })();\n\n            protocol.RefreshResult = (function() {\n\n                /**\n                 * Properties of a RefreshResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IRefreshResult\n                 * @property {string|null} [client] RefreshResult client\n                 * @property {string|null} [version] RefreshResult version\n                 * @property {boolean|null} [expires] RefreshResult expires\n                 * @property {number|null} [ttl] RefreshResult ttl\n                 */\n\n                /**\n                 * Constructs a new RefreshResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a RefreshResult.\n                 * @implements IRefreshResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IRefreshResult=} [properties] Properties to set\n                 */\n                function RefreshResult(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * RefreshResult client.\n                 * @member {string} client\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @instance\n                 */\n                RefreshResult.prototype.client = \"\";\n\n                /**\n                 * RefreshResult version.\n                 * @member {string} version\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @instance\n                 */\n                RefreshResult.prototype.version = \"\";\n\n                /**\n                 * RefreshResult expires.\n                 * @member {boolean} expires\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @instance\n                 */\n                RefreshResult.prototype.expires = false;\n\n                /**\n                 * RefreshResult ttl.\n                 * @member {number} ttl\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @instance\n                 */\n                RefreshResult.prototype.ttl = 0;\n\n                /**\n                 * Encodes the specified RefreshResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.RefreshResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRefreshResult} message RefreshResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                RefreshResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.client != null && Object.hasOwnProperty.call(message, \"client\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.client);\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);\n                    if (message.expires != null && Object.hasOwnProperty.call(message, \"expires\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.expires);\n                    if (message.ttl != null && Object.hasOwnProperty.call(message, \"ttl\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.ttl);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified RefreshResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.RefreshResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRefreshResult} message RefreshResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                RefreshResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a RefreshResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.RefreshResult} RefreshResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                RefreshResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.RefreshResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.client = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.version = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.expires = reader.bool();\n                                break;\n                            }\n                        case 4: {\n                                message.ttl = reader.uint32();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a RefreshResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.RefreshResult} RefreshResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                RefreshResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a RefreshResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                RefreshResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.client != null && message.hasOwnProperty(\"client\"))\n                        if (!$util.isString(message.client))\n                            return \"client: string expected\";\n                    if (message.version != null && message.hasOwnProperty(\"version\"))\n                        if (!$util.isString(message.version))\n                            return \"version: string expected\";\n                    if (message.expires != null && message.hasOwnProperty(\"expires\"))\n                        if (typeof message.expires !== \"boolean\")\n                            return \"expires: boolean expected\";\n                    if (message.ttl != null && message.hasOwnProperty(\"ttl\"))\n                        if (!$util.isInteger(message.ttl))\n                            return \"ttl: integer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for RefreshResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.RefreshResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                RefreshResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.RefreshResult\";\n                };\n\n                return RefreshResult;\n            })();\n\n            protocol.SubscribeRequest = (function() {\n\n                /**\n                 * Properties of a SubscribeRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface ISubscribeRequest\n                 * @property {string|null} [channel] SubscribeRequest channel\n                 * @property {string|null} [token] SubscribeRequest token\n                 * @property {boolean|null} [recover] SubscribeRequest recover\n                 * @property {string|null} [epoch] SubscribeRequest epoch\n                 * @property {number|Long|null} [offset] SubscribeRequest offset\n                 * @property {Uint8Array|null} [data] SubscribeRequest data\n                 * @property {boolean|null} [positioned] SubscribeRequest positioned\n                 * @property {boolean|null} [recoverable] SubscribeRequest recoverable\n                 * @property {boolean|null} [join_leave] SubscribeRequest join_leave\n                 * @property {string|null} [delta] SubscribeRequest delta\n                 * @property {centrifugal.centrifuge.protocol.IFilterNode|null} [tf] SubscribeRequest tf\n                 * @property {number|Long|null} [flag] SubscribeRequest flag\n                 */\n\n                /**\n                 * Constructs a new SubscribeRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a SubscribeRequest.\n                 * @implements ISubscribeRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.ISubscribeRequest=} [properties] Properties to set\n                 */\n                function SubscribeRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * SubscribeRequest channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.channel = \"\";\n\n                /**\n                 * SubscribeRequest token.\n                 * @member {string} token\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.token = \"\";\n\n                /**\n                 * SubscribeRequest recover.\n                 * @member {boolean} recover\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.recover = false;\n\n                /**\n                 * SubscribeRequest epoch.\n                 * @member {string} epoch\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.epoch = \"\";\n\n                /**\n                 * SubscribeRequest offset.\n                 * @member {number|Long} offset\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                /**\n                 * SubscribeRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * SubscribeRequest positioned.\n                 * @member {boolean} positioned\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.positioned = false;\n\n                /**\n                 * SubscribeRequest recoverable.\n                 * @member {boolean} recoverable\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.recoverable = false;\n\n                /**\n                 * SubscribeRequest join_leave.\n                 * @member {boolean} join_leave\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.join_leave = false;\n\n                /**\n                 * SubscribeRequest delta.\n                 * @member {string} delta\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.delta = \"\";\n\n                /**\n                 * SubscribeRequest tf.\n                 * @member {centrifugal.centrifuge.protocol.IFilterNode|null|undefined} tf\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.tf = null;\n\n                /**\n                 * SubscribeRequest flag.\n                 * @member {number|Long} flag\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @instance\n                 */\n                SubscribeRequest.prototype.flag = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                /**\n                 * Encodes the specified SubscribeRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.SubscribeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubscribeRequest} message SubscribeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SubscribeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                    if (message.token != null && Object.hasOwnProperty.call(message, \"token\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);\n                    if (message.recover != null && Object.hasOwnProperty.call(message, \"recover\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.recover);\n                    if (message.epoch != null && Object.hasOwnProperty.call(message, \"epoch\"))\n                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.epoch);\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.offset);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.data);\n                    if (message.positioned != null && Object.hasOwnProperty.call(message, \"positioned\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.positioned);\n                    if (message.recoverable != null && Object.hasOwnProperty.call(message, \"recoverable\"))\n                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.recoverable);\n                    if (message.join_leave != null && Object.hasOwnProperty.call(message, \"join_leave\"))\n                        writer.uint32(/* id 11, wireType 0 =*/88).bool(message.join_leave);\n                    if (message.delta != null && Object.hasOwnProperty.call(message, \"delta\"))\n                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.delta);\n                    if (message.tf != null && Object.hasOwnProperty.call(message, \"tf\"))\n                        $root.centrifugal.centrifuge.protocol.FilterNode.encode(message.tf, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n                    if (message.flag != null && Object.hasOwnProperty.call(message, \"flag\"))\n                        writer.uint32(/* id 14, wireType 0 =*/112).int64(message.flag);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified SubscribeRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.SubscribeRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubscribeRequest} message SubscribeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a SubscribeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.SubscribeRequest} SubscribeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SubscribeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.SubscribeRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.token = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.recover = reader.bool();\n                                break;\n                            }\n                        case 6: {\n                                message.epoch = reader.string();\n                                break;\n                            }\n                        case 7: {\n                                message.offset = reader.uint64();\n                                break;\n                            }\n                        case 8: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        case 9: {\n                                message.positioned = reader.bool();\n                                break;\n                            }\n                        case 10: {\n                                message.recoverable = reader.bool();\n                                break;\n                            }\n                        case 11: {\n                                message.join_leave = reader.bool();\n                                break;\n                            }\n                        case 12: {\n                                message.delta = reader.string();\n                                break;\n                            }\n                        case 13: {\n                                message.tf = $root.centrifugal.centrifuge.protocol.FilterNode.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 14: {\n                                message.flag = reader.int64();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a SubscribeRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.SubscribeRequest} SubscribeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SubscribeRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a SubscribeRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                SubscribeRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    if (message.token != null && message.hasOwnProperty(\"token\"))\n                        if (!$util.isString(message.token))\n                            return \"token: string expected\";\n                    if (message.recover != null && message.hasOwnProperty(\"recover\"))\n                        if (typeof message.recover !== \"boolean\")\n                            return \"recover: boolean expected\";\n                    if (message.epoch != null && message.hasOwnProperty(\"epoch\"))\n                        if (!$util.isString(message.epoch))\n                            return \"epoch: string expected\";\n                    if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))\n                            return \"offset: integer|Long expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    if (message.positioned != null && message.hasOwnProperty(\"positioned\"))\n                        if (typeof message.positioned !== \"boolean\")\n                            return \"positioned: boolean expected\";\n                    if (message.recoverable != null && message.hasOwnProperty(\"recoverable\"))\n                        if (typeof message.recoverable !== \"boolean\")\n                            return \"recoverable: boolean expected\";\n                    if (message.join_leave != null && message.hasOwnProperty(\"join_leave\"))\n                        if (typeof message.join_leave !== \"boolean\")\n                            return \"join_leave: boolean expected\";\n                    if (message.delta != null && message.hasOwnProperty(\"delta\"))\n                        if (!$util.isString(message.delta))\n                            return \"delta: string expected\";\n                    if (message.tf != null && message.hasOwnProperty(\"tf\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.FilterNode.verify(message.tf);\n                        if (error)\n                            return \"tf.\" + error;\n                    }\n                    if (message.flag != null && message.hasOwnProperty(\"flag\"))\n                        if (!$util.isInteger(message.flag) && !(message.flag && $util.isInteger(message.flag.low) && $util.isInteger(message.flag.high)))\n                            return \"flag: integer|Long expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for SubscribeRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                SubscribeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.SubscribeRequest\";\n                };\n\n                return SubscribeRequest;\n            })();\n\n            protocol.SubscribeResult = (function() {\n\n                /**\n                 * Properties of a SubscribeResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface ISubscribeResult\n                 * @property {boolean|null} [expires] SubscribeResult expires\n                 * @property {number|null} [ttl] SubscribeResult ttl\n                 * @property {boolean|null} [recoverable] SubscribeResult recoverable\n                 * @property {string|null} [epoch] SubscribeResult epoch\n                 * @property {Array.<centrifugal.centrifuge.protocol.IPublication>|null} [publications] SubscribeResult publications\n                 * @property {boolean|null} [recovered] SubscribeResult recovered\n                 * @property {number|Long|null} [offset] SubscribeResult offset\n                 * @property {boolean|null} [positioned] SubscribeResult positioned\n                 * @property {Uint8Array|null} [data] SubscribeResult data\n                 * @property {boolean|null} [was_recovering] SubscribeResult was_recovering\n                 * @property {boolean|null} [delta] SubscribeResult delta\n                 * @property {number|Long|null} [id] SubscribeResult id\n                 */\n\n                /**\n                 * Constructs a new SubscribeResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a SubscribeResult.\n                 * @implements ISubscribeResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.ISubscribeResult=} [properties] Properties to set\n                 */\n                function SubscribeResult(properties) {\n                    this.publications = [];\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * SubscribeResult expires.\n                 * @member {boolean} expires\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.expires = false;\n\n                /**\n                 * SubscribeResult ttl.\n                 * @member {number} ttl\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.ttl = 0;\n\n                /**\n                 * SubscribeResult recoverable.\n                 * @member {boolean} recoverable\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.recoverable = false;\n\n                /**\n                 * SubscribeResult epoch.\n                 * @member {string} epoch\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.epoch = \"\";\n\n                /**\n                 * SubscribeResult publications.\n                 * @member {Array.<centrifugal.centrifuge.protocol.IPublication>} publications\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.publications = $util.emptyArray;\n\n                /**\n                 * SubscribeResult recovered.\n                 * @member {boolean} recovered\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.recovered = false;\n\n                /**\n                 * SubscribeResult offset.\n                 * @member {number|Long} offset\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                /**\n                 * SubscribeResult positioned.\n                 * @member {boolean} positioned\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.positioned = false;\n\n                /**\n                 * SubscribeResult data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * SubscribeResult was_recovering.\n                 * @member {boolean} was_recovering\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.was_recovering = false;\n\n                /**\n                 * SubscribeResult delta.\n                 * @member {boolean} delta\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.delta = false;\n\n                /**\n                 * SubscribeResult id.\n                 * @member {number|Long} id\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @instance\n                 */\n                SubscribeResult.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n                /**\n                 * Encodes the specified SubscribeResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.SubscribeResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubscribeResult} message SubscribeResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SubscribeResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.expires != null && Object.hasOwnProperty.call(message, \"expires\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.expires);\n                    if (message.ttl != null && Object.hasOwnProperty.call(message, \"ttl\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ttl);\n                    if (message.recoverable != null && Object.hasOwnProperty.call(message, \"recoverable\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.recoverable);\n                    if (message.epoch != null && Object.hasOwnProperty.call(message, \"epoch\"))\n                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.epoch);\n                    if (message.publications != null && message.publications.length)\n                        for (let i = 0; i < message.publications.length; ++i)\n                            $root.centrifugal.centrifuge.protocol.Publication.encode(message.publications[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.recovered != null && Object.hasOwnProperty.call(message, \"recovered\"))\n                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.recovered);\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.offset);\n                    if (message.positioned != null && Object.hasOwnProperty.call(message, \"positioned\"))\n                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.positioned);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.data);\n                    if (message.was_recovering != null && Object.hasOwnProperty.call(message, \"was_recovering\"))\n                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.was_recovering);\n                    if (message.delta != null && Object.hasOwnProperty.call(message, \"delta\"))\n                        writer.uint32(/* id 13, wireType 0 =*/104).bool(message.delta);\n                    if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                        writer.uint32(/* id 14, wireType 0 =*/112).int64(message.id);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified SubscribeResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.SubscribeResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubscribeResult} message SubscribeResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SubscribeResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a SubscribeResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.SubscribeResult} SubscribeResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SubscribeResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.SubscribeResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.expires = reader.bool();\n                                break;\n                            }\n                        case 2: {\n                                message.ttl = reader.uint32();\n                                break;\n                            }\n                        case 3: {\n                                message.recoverable = reader.bool();\n                                break;\n                            }\n                        case 6: {\n                                message.epoch = reader.string();\n                                break;\n                            }\n                        case 7: {\n                                if (!(message.publications && message.publications.length))\n                                    message.publications = [];\n                                message.publications.push($root.centrifugal.centrifuge.protocol.Publication.decode(reader, reader.uint32()));\n                                break;\n                            }\n                        case 8: {\n                                message.recovered = reader.bool();\n                                break;\n                            }\n                        case 9: {\n                                message.offset = reader.uint64();\n                                break;\n                            }\n                        case 10: {\n                                message.positioned = reader.bool();\n                                break;\n                            }\n                        case 11: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        case 12: {\n                                message.was_recovering = reader.bool();\n                                break;\n                            }\n                        case 13: {\n                                message.delta = reader.bool();\n                                break;\n                            }\n                        case 14: {\n                                message.id = reader.int64();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a SubscribeResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.SubscribeResult} SubscribeResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SubscribeResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a SubscribeResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                SubscribeResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.expires != null && message.hasOwnProperty(\"expires\"))\n                        if (typeof message.expires !== \"boolean\")\n                            return \"expires: boolean expected\";\n                    if (message.ttl != null && message.hasOwnProperty(\"ttl\"))\n                        if (!$util.isInteger(message.ttl))\n                            return \"ttl: integer expected\";\n                    if (message.recoverable != null && message.hasOwnProperty(\"recoverable\"))\n                        if (typeof message.recoverable !== \"boolean\")\n                            return \"recoverable: boolean expected\";\n                    if (message.epoch != null && message.hasOwnProperty(\"epoch\"))\n                        if (!$util.isString(message.epoch))\n                            return \"epoch: string expected\";\n                    if (message.publications != null && message.hasOwnProperty(\"publications\")) {\n                        if (!Array.isArray(message.publications))\n                            return \"publications: array expected\";\n                        for (let i = 0; i < message.publications.length; ++i) {\n                            let error = $root.centrifugal.centrifuge.protocol.Publication.verify(message.publications[i]);\n                            if (error)\n                                return \"publications.\" + error;\n                        }\n                    }\n                    if (message.recovered != null && message.hasOwnProperty(\"recovered\"))\n                        if (typeof message.recovered !== \"boolean\")\n                            return \"recovered: boolean expected\";\n                    if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))\n                            return \"offset: integer|Long expected\";\n                    if (message.positioned != null && message.hasOwnProperty(\"positioned\"))\n                        if (typeof message.positioned !== \"boolean\")\n                            return \"positioned: boolean expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    if (message.was_recovering != null && message.hasOwnProperty(\"was_recovering\"))\n                        if (typeof message.was_recovering !== \"boolean\")\n                            return \"was_recovering: boolean expected\";\n                    if (message.delta != null && message.hasOwnProperty(\"delta\"))\n                        if (typeof message.delta !== \"boolean\")\n                            return \"delta: boolean expected\";\n                    if (message.id != null && message.hasOwnProperty(\"id\"))\n                        if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))\n                            return \"id: integer|Long expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for SubscribeResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.SubscribeResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                SubscribeResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.SubscribeResult\";\n                };\n\n                return SubscribeResult;\n            })();\n\n            protocol.SubRefreshRequest = (function() {\n\n                /**\n                 * Properties of a SubRefreshRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface ISubRefreshRequest\n                 * @property {string|null} [channel] SubRefreshRequest channel\n                 * @property {string|null} [token] SubRefreshRequest token\n                 */\n\n                /**\n                 * Constructs a new SubRefreshRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a SubRefreshRequest.\n                 * @implements ISubRefreshRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.ISubRefreshRequest=} [properties] Properties to set\n                 */\n                function SubRefreshRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * SubRefreshRequest channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshRequest\n                 * @instance\n                 */\n                SubRefreshRequest.prototype.channel = \"\";\n\n                /**\n                 * SubRefreshRequest token.\n                 * @member {string} token\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshRequest\n                 * @instance\n                 */\n                SubRefreshRequest.prototype.token = \"\";\n\n                /**\n                 * Encodes the specified SubRefreshRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.SubRefreshRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubRefreshRequest} message SubRefreshRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SubRefreshRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                    if (message.token != null && Object.hasOwnProperty.call(message, \"token\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.token);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified SubRefreshRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.SubRefreshRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubRefreshRequest} message SubRefreshRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SubRefreshRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a SubRefreshRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.SubRefreshRequest} SubRefreshRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SubRefreshRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.SubRefreshRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.token = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a SubRefreshRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.SubRefreshRequest} SubRefreshRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SubRefreshRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a SubRefreshRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                SubRefreshRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    if (message.token != null && message.hasOwnProperty(\"token\"))\n                        if (!$util.isString(message.token))\n                            return \"token: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for SubRefreshRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                SubRefreshRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.SubRefreshRequest\";\n                };\n\n                return SubRefreshRequest;\n            })();\n\n            protocol.SubRefreshResult = (function() {\n\n                /**\n                 * Properties of a SubRefreshResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface ISubRefreshResult\n                 * @property {boolean|null} [expires] SubRefreshResult expires\n                 * @property {number|null} [ttl] SubRefreshResult ttl\n                 */\n\n                /**\n                 * Constructs a new SubRefreshResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a SubRefreshResult.\n                 * @implements ISubRefreshResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.ISubRefreshResult=} [properties] Properties to set\n                 */\n                function SubRefreshResult(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * SubRefreshResult expires.\n                 * @member {boolean} expires\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshResult\n                 * @instance\n                 */\n                SubRefreshResult.prototype.expires = false;\n\n                /**\n                 * SubRefreshResult ttl.\n                 * @member {number} ttl\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshResult\n                 * @instance\n                 */\n                SubRefreshResult.prototype.ttl = 0;\n\n                /**\n                 * Encodes the specified SubRefreshResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.SubRefreshResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubRefreshResult} message SubRefreshResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SubRefreshResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.expires != null && Object.hasOwnProperty.call(message, \"expires\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.expires);\n                    if (message.ttl != null && Object.hasOwnProperty.call(message, \"ttl\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ttl);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified SubRefreshResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.SubRefreshResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISubRefreshResult} message SubRefreshResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SubRefreshResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a SubRefreshResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.SubRefreshResult} SubRefreshResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SubRefreshResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.SubRefreshResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.expires = reader.bool();\n                                break;\n                            }\n                        case 2: {\n                                message.ttl = reader.uint32();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a SubRefreshResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.SubRefreshResult} SubRefreshResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SubRefreshResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a SubRefreshResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                SubRefreshResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.expires != null && message.hasOwnProperty(\"expires\"))\n                        if (typeof message.expires !== \"boolean\")\n                            return \"expires: boolean expected\";\n                    if (message.ttl != null && message.hasOwnProperty(\"ttl\"))\n                        if (!$util.isInteger(message.ttl))\n                            return \"ttl: integer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for SubRefreshResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.SubRefreshResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                SubRefreshResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.SubRefreshResult\";\n                };\n\n                return SubRefreshResult;\n            })();\n\n            protocol.UnsubscribeRequest = (function() {\n\n                /**\n                 * Properties of an UnsubscribeRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IUnsubscribeRequest\n                 * @property {string|null} [channel] UnsubscribeRequest channel\n                 */\n\n                /**\n                 * Constructs a new UnsubscribeRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents an UnsubscribeRequest.\n                 * @implements IUnsubscribeRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribeRequest=} [properties] Properties to set\n                 */\n                function UnsubscribeRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * UnsubscribeRequest channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeRequest\n                 * @instance\n                 */\n                UnsubscribeRequest.prototype.channel = \"\";\n\n                /**\n                 * Encodes the specified UnsubscribeRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.UnsubscribeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribeRequest} message UnsubscribeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                UnsubscribeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified UnsubscribeRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.UnsubscribeRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribeRequest} message UnsubscribeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                UnsubscribeRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes an UnsubscribeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.UnsubscribeRequest} UnsubscribeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                UnsubscribeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.UnsubscribeRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes an UnsubscribeRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.UnsubscribeRequest} UnsubscribeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                UnsubscribeRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies an UnsubscribeRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                UnsubscribeRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for UnsubscribeRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                UnsubscribeRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.UnsubscribeRequest\";\n                };\n\n                return UnsubscribeRequest;\n            })();\n\n            protocol.UnsubscribeResult = (function() {\n\n                /**\n                 * Properties of an UnsubscribeResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IUnsubscribeResult\n                 */\n\n                /**\n                 * Constructs a new UnsubscribeResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents an UnsubscribeResult.\n                 * @implements IUnsubscribeResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribeResult=} [properties] Properties to set\n                 */\n                function UnsubscribeResult(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Encodes the specified UnsubscribeResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.UnsubscribeResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribeResult} message UnsubscribeResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                UnsubscribeResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified UnsubscribeResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.UnsubscribeResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IUnsubscribeResult} message UnsubscribeResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                UnsubscribeResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes an UnsubscribeResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.UnsubscribeResult} UnsubscribeResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                UnsubscribeResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.UnsubscribeResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes an UnsubscribeResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.UnsubscribeResult} UnsubscribeResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                UnsubscribeResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies an UnsubscribeResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                UnsubscribeResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for UnsubscribeResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.UnsubscribeResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                UnsubscribeResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.UnsubscribeResult\";\n                };\n\n                return UnsubscribeResult;\n            })();\n\n            protocol.PublishRequest = (function() {\n\n                /**\n                 * Properties of a PublishRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPublishRequest\n                 * @property {string|null} [channel] PublishRequest channel\n                 * @property {Uint8Array|null} [data] PublishRequest data\n                 */\n\n                /**\n                 * Constructs a new PublishRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a PublishRequest.\n                 * @implements IPublishRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPublishRequest=} [properties] Properties to set\n                 */\n                function PublishRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * PublishRequest channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.PublishRequest\n                 * @instance\n                 */\n                PublishRequest.prototype.channel = \"\";\n\n                /**\n                 * PublishRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.PublishRequest\n                 * @instance\n                 */\n                PublishRequest.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * Encodes the specified PublishRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.PublishRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.PublishRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPublishRequest} message PublishRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PublishRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified PublishRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.PublishRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PublishRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPublishRequest} message PublishRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PublishRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a PublishRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.PublishRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.PublishRequest} PublishRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PublishRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.PublishRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a PublishRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PublishRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.PublishRequest} PublishRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PublishRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a PublishRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.PublishRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PublishRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for PublishRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.PublishRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                PublishRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.PublishRequest\";\n                };\n\n                return PublishRequest;\n            })();\n\n            protocol.PublishResult = (function() {\n\n                /**\n                 * Properties of a PublishResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPublishResult\n                 */\n\n                /**\n                 * Constructs a new PublishResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a PublishResult.\n                 * @implements IPublishResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPublishResult=} [properties] Properties to set\n                 */\n                function PublishResult(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Encodes the specified PublishResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.PublishResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.PublishResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPublishResult} message PublishResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PublishResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified PublishResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.PublishResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PublishResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPublishResult} message PublishResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PublishResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a PublishResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.PublishResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.PublishResult} PublishResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PublishResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.PublishResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a PublishResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PublishResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.PublishResult} PublishResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PublishResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a PublishResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.PublishResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PublishResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for PublishResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.PublishResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                PublishResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.PublishResult\";\n                };\n\n                return PublishResult;\n            })();\n\n            protocol.PresenceRequest = (function() {\n\n                /**\n                 * Properties of a PresenceRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPresenceRequest\n                 * @property {string|null} [channel] PresenceRequest channel\n                 */\n\n                /**\n                 * Constructs a new PresenceRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a PresenceRequest.\n                 * @implements IPresenceRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPresenceRequest=} [properties] Properties to set\n                 */\n                function PresenceRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * PresenceRequest channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.PresenceRequest\n                 * @instance\n                 */\n                PresenceRequest.prototype.channel = \"\";\n\n                /**\n                 * Encodes the specified PresenceRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.PresenceRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.PresenceRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPresenceRequest} message PresenceRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PresenceRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified PresenceRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.PresenceRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PresenceRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPresenceRequest} message PresenceRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PresenceRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a PresenceRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.PresenceRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.PresenceRequest} PresenceRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PresenceRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.PresenceRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a PresenceRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PresenceRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.PresenceRequest} PresenceRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PresenceRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a PresenceRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.PresenceRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PresenceRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for PresenceRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.PresenceRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                PresenceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.PresenceRequest\";\n                };\n\n                return PresenceRequest;\n            })();\n\n            protocol.PresenceResult = (function() {\n\n                /**\n                 * Properties of a PresenceResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPresenceResult\n                 * @property {Object.<string,centrifugal.centrifuge.protocol.IClientInfo>|null} [presence] PresenceResult presence\n                 */\n\n                /**\n                 * Constructs a new PresenceResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a PresenceResult.\n                 * @implements IPresenceResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPresenceResult=} [properties] Properties to set\n                 */\n                function PresenceResult(properties) {\n                    this.presence = {};\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * PresenceResult presence.\n                 * @member {Object.<string,centrifugal.centrifuge.protocol.IClientInfo>} presence\n                 * @memberof centrifugal.centrifuge.protocol.PresenceResult\n                 * @instance\n                 */\n                PresenceResult.prototype.presence = $util.emptyObject;\n\n                /**\n                 * Encodes the specified PresenceResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.PresenceResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.PresenceResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPresenceResult} message PresenceResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PresenceResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.presence != null && Object.hasOwnProperty.call(message, \"presence\"))\n                        for (let keys = Object.keys(message.presence), i = 0; i < keys.length; ++i) {\n                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);\n                            $root.centrifugal.centrifuge.protocol.ClientInfo.encode(message.presence[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();\n                        }\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified PresenceResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.PresenceResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PresenceResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPresenceResult} message PresenceResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PresenceResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a PresenceResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.PresenceResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.PresenceResult} PresenceResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PresenceResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.PresenceResult(), key, value;\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                if (message.presence === $util.emptyObject)\n                                    message.presence = {};\n                                let end2 = reader.uint32() + reader.pos;\n                                key = \"\";\n                                value = null;\n                                while (reader.pos < end2) {\n                                    let tag2 = reader.uint32();\n                                    switch (tag2 >>> 3) {\n                                    case 1:\n                                        key = reader.string();\n                                        break;\n                                    case 2:\n                                        value = $root.centrifugal.centrifuge.protocol.ClientInfo.decode(reader, reader.uint32());\n                                        break;\n                                    default:\n                                        reader.skipType(tag2 & 7);\n                                        break;\n                                    }\n                                }\n                                message.presence[key] = value;\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a PresenceResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PresenceResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.PresenceResult} PresenceResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PresenceResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a PresenceResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.PresenceResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PresenceResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.presence != null && message.hasOwnProperty(\"presence\")) {\n                        if (!$util.isObject(message.presence))\n                            return \"presence: object expected\";\n                        let key = Object.keys(message.presence);\n                        for (let i = 0; i < key.length; ++i) {\n                            let error = $root.centrifugal.centrifuge.protocol.ClientInfo.verify(message.presence[key[i]]);\n                            if (error)\n                                return \"presence.\" + error;\n                        }\n                    }\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for PresenceResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.PresenceResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                PresenceResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.PresenceResult\";\n                };\n\n                return PresenceResult;\n            })();\n\n            protocol.PresenceStatsRequest = (function() {\n\n                /**\n                 * Properties of a PresenceStatsRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPresenceStatsRequest\n                 * @property {string|null} [channel] PresenceStatsRequest channel\n                 */\n\n                /**\n                 * Constructs a new PresenceStatsRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a PresenceStatsRequest.\n                 * @implements IPresenceStatsRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPresenceStatsRequest=} [properties] Properties to set\n                 */\n                function PresenceStatsRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * PresenceStatsRequest channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsRequest\n                 * @instance\n                 */\n                PresenceStatsRequest.prototype.channel = \"\";\n\n                /**\n                 * Encodes the specified PresenceStatsRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.PresenceStatsRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPresenceStatsRequest} message PresenceStatsRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PresenceStatsRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified PresenceStatsRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.PresenceStatsRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPresenceStatsRequest} message PresenceStatsRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PresenceStatsRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a PresenceStatsRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.PresenceStatsRequest} PresenceStatsRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PresenceStatsRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.PresenceStatsRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a PresenceStatsRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.PresenceStatsRequest} PresenceStatsRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PresenceStatsRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a PresenceStatsRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PresenceStatsRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for PresenceStatsRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                PresenceStatsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.PresenceStatsRequest\";\n                };\n\n                return PresenceStatsRequest;\n            })();\n\n            protocol.PresenceStatsResult = (function() {\n\n                /**\n                 * Properties of a PresenceStatsResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPresenceStatsResult\n                 * @property {number|null} [num_clients] PresenceStatsResult num_clients\n                 * @property {number|null} [num_users] PresenceStatsResult num_users\n                 */\n\n                /**\n                 * Constructs a new PresenceStatsResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a PresenceStatsResult.\n                 * @implements IPresenceStatsResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPresenceStatsResult=} [properties] Properties to set\n                 */\n                function PresenceStatsResult(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * PresenceStatsResult num_clients.\n                 * @member {number} num_clients\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsResult\n                 * @instance\n                 */\n                PresenceStatsResult.prototype.num_clients = 0;\n\n                /**\n                 * PresenceStatsResult num_users.\n                 * @member {number} num_users\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsResult\n                 * @instance\n                 */\n                PresenceStatsResult.prototype.num_users = 0;\n\n                /**\n                 * Encodes the specified PresenceStatsResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.PresenceStatsResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPresenceStatsResult} message PresenceStatsResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PresenceStatsResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.num_clients != null && Object.hasOwnProperty.call(message, \"num_clients\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.num_clients);\n                    if (message.num_users != null && Object.hasOwnProperty.call(message, \"num_users\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num_users);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified PresenceStatsResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.PresenceStatsResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPresenceStatsResult} message PresenceStatsResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PresenceStatsResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a PresenceStatsResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.PresenceStatsResult} PresenceStatsResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PresenceStatsResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.PresenceStatsResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.num_clients = reader.uint32();\n                                break;\n                            }\n                        case 2: {\n                                message.num_users = reader.uint32();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a PresenceStatsResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.PresenceStatsResult} PresenceStatsResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PresenceStatsResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a PresenceStatsResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PresenceStatsResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.num_clients != null && message.hasOwnProperty(\"num_clients\"))\n                        if (!$util.isInteger(message.num_clients))\n                            return \"num_clients: integer expected\";\n                    if (message.num_users != null && message.hasOwnProperty(\"num_users\"))\n                        if (!$util.isInteger(message.num_users))\n                            return \"num_users: integer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for PresenceStatsResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.PresenceStatsResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                PresenceStatsResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.PresenceStatsResult\";\n                };\n\n                return PresenceStatsResult;\n            })();\n\n            protocol.StreamPosition = (function() {\n\n                /**\n                 * Properties of a StreamPosition.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IStreamPosition\n                 * @property {number|Long|null} [offset] StreamPosition offset\n                 * @property {string|null} [epoch] StreamPosition epoch\n                 */\n\n                /**\n                 * Constructs a new StreamPosition.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a StreamPosition.\n                 * @implements IStreamPosition\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IStreamPosition=} [properties] Properties to set\n                 */\n                function StreamPosition(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * StreamPosition offset.\n                 * @member {number|Long} offset\n                 * @memberof centrifugal.centrifuge.protocol.StreamPosition\n                 * @instance\n                 */\n                StreamPosition.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                /**\n                 * StreamPosition epoch.\n                 * @member {string} epoch\n                 * @memberof centrifugal.centrifuge.protocol.StreamPosition\n                 * @instance\n                 */\n                StreamPosition.prototype.epoch = \"\";\n\n                /**\n                 * Encodes the specified StreamPosition message. Does not implicitly {@link centrifugal.centrifuge.protocol.StreamPosition.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.StreamPosition\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IStreamPosition} message StreamPosition message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StreamPosition.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.offset);\n                    if (message.epoch != null && Object.hasOwnProperty.call(message, \"epoch\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.epoch);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified StreamPosition message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.StreamPosition.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.StreamPosition\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IStreamPosition} message StreamPosition message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StreamPosition.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a StreamPosition message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.StreamPosition\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.StreamPosition} StreamPosition\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StreamPosition.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.StreamPosition();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.offset = reader.uint64();\n                                break;\n                            }\n                        case 2: {\n                                message.epoch = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a StreamPosition message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.StreamPosition\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.StreamPosition} StreamPosition\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StreamPosition.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a StreamPosition message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.StreamPosition\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                StreamPosition.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))\n                            return \"offset: integer|Long expected\";\n                    if (message.epoch != null && message.hasOwnProperty(\"epoch\"))\n                        if (!$util.isString(message.epoch))\n                            return \"epoch: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for StreamPosition\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.StreamPosition\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                StreamPosition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.StreamPosition\";\n                };\n\n                return StreamPosition;\n            })();\n\n            protocol.HistoryRequest = (function() {\n\n                /**\n                 * Properties of a HistoryRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IHistoryRequest\n                 * @property {string|null} [channel] HistoryRequest channel\n                 * @property {number|null} [limit] HistoryRequest limit\n                 * @property {centrifugal.centrifuge.protocol.IStreamPosition|null} [since] HistoryRequest since\n                 * @property {boolean|null} [reverse] HistoryRequest reverse\n                 */\n\n                /**\n                 * Constructs a new HistoryRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a HistoryRequest.\n                 * @implements IHistoryRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IHistoryRequest=} [properties] Properties to set\n                 */\n                function HistoryRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * HistoryRequest channel.\n                 * @member {string} channel\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @instance\n                 */\n                HistoryRequest.prototype.channel = \"\";\n\n                /**\n                 * HistoryRequest limit.\n                 * @member {number} limit\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @instance\n                 */\n                HistoryRequest.prototype.limit = 0;\n\n                /**\n                 * HistoryRequest since.\n                 * @member {centrifugal.centrifuge.protocol.IStreamPosition|null|undefined} since\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @instance\n                 */\n                HistoryRequest.prototype.since = null;\n\n                /**\n                 * HistoryRequest reverse.\n                 * @member {boolean} reverse\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @instance\n                 */\n                HistoryRequest.prototype.reverse = false;\n\n                /**\n                 * Encodes the specified HistoryRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.HistoryRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IHistoryRequest} message HistoryRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                HistoryRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);\n                    if (message.limit != null && Object.hasOwnProperty.call(message, \"limit\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.limit);\n                    if (message.since != null && Object.hasOwnProperty.call(message, \"since\"))\n                        $root.centrifugal.centrifuge.protocol.StreamPosition.encode(message.since, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.reverse != null && Object.hasOwnProperty.call(message, \"reverse\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.reverse);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified HistoryRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.HistoryRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IHistoryRequest} message HistoryRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                HistoryRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a HistoryRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.HistoryRequest} HistoryRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                HistoryRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.HistoryRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.channel = reader.string();\n                                break;\n                            }\n                        case 7: {\n                                message.limit = reader.int32();\n                                break;\n                            }\n                        case 8: {\n                                message.since = $root.centrifugal.centrifuge.protocol.StreamPosition.decode(reader, reader.uint32());\n                                break;\n                            }\n                        case 9: {\n                                message.reverse = reader.bool();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a HistoryRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.HistoryRequest} HistoryRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                HistoryRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a HistoryRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                HistoryRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.channel != null && message.hasOwnProperty(\"channel\"))\n                        if (!$util.isString(message.channel))\n                            return \"channel: string expected\";\n                    if (message.limit != null && message.hasOwnProperty(\"limit\"))\n                        if (!$util.isInteger(message.limit))\n                            return \"limit: integer expected\";\n                    if (message.since != null && message.hasOwnProperty(\"since\")) {\n                        let error = $root.centrifugal.centrifuge.protocol.StreamPosition.verify(message.since);\n                        if (error)\n                            return \"since.\" + error;\n                    }\n                    if (message.reverse != null && message.hasOwnProperty(\"reverse\"))\n                        if (typeof message.reverse !== \"boolean\")\n                            return \"reverse: boolean expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for HistoryRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.HistoryRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                HistoryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.HistoryRequest\";\n                };\n\n                return HistoryRequest;\n            })();\n\n            protocol.HistoryResult = (function() {\n\n                /**\n                 * Properties of a HistoryResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IHistoryResult\n                 * @property {Array.<centrifugal.centrifuge.protocol.IPublication>|null} [publications] HistoryResult publications\n                 * @property {string|null} [epoch] HistoryResult epoch\n                 * @property {number|Long|null} [offset] HistoryResult offset\n                 */\n\n                /**\n                 * Constructs a new HistoryResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a HistoryResult.\n                 * @implements IHistoryResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IHistoryResult=} [properties] Properties to set\n                 */\n                function HistoryResult(properties) {\n                    this.publications = [];\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * HistoryResult publications.\n                 * @member {Array.<centrifugal.centrifuge.protocol.IPublication>} publications\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @instance\n                 */\n                HistoryResult.prototype.publications = $util.emptyArray;\n\n                /**\n                 * HistoryResult epoch.\n                 * @member {string} epoch\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @instance\n                 */\n                HistoryResult.prototype.epoch = \"\";\n\n                /**\n                 * HistoryResult offset.\n                 * @member {number|Long} offset\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @instance\n                 */\n                HistoryResult.prototype.offset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n                /**\n                 * Encodes the specified HistoryResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.HistoryResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IHistoryResult} message HistoryResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                HistoryResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.publications != null && message.publications.length)\n                        for (let i = 0; i < message.publications.length; ++i)\n                            $root.centrifugal.centrifuge.protocol.Publication.encode(message.publications[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.epoch != null && Object.hasOwnProperty.call(message, \"epoch\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.epoch);\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.offset);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified HistoryResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.HistoryResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IHistoryResult} message HistoryResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                HistoryResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a HistoryResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.HistoryResult} HistoryResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                HistoryResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.HistoryResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                if (!(message.publications && message.publications.length))\n                                    message.publications = [];\n                                message.publications.push($root.centrifugal.centrifuge.protocol.Publication.decode(reader, reader.uint32()));\n                                break;\n                            }\n                        case 2: {\n                                message.epoch = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.offset = reader.uint64();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a HistoryResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.HistoryResult} HistoryResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                HistoryResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a HistoryResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                HistoryResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.publications != null && message.hasOwnProperty(\"publications\")) {\n                        if (!Array.isArray(message.publications))\n                            return \"publications: array expected\";\n                        for (let i = 0; i < message.publications.length; ++i) {\n                            let error = $root.centrifugal.centrifuge.protocol.Publication.verify(message.publications[i]);\n                            if (error)\n                                return \"publications.\" + error;\n                        }\n                    }\n                    if (message.epoch != null && message.hasOwnProperty(\"epoch\"))\n                        if (!$util.isString(message.epoch))\n                            return \"epoch: string expected\";\n                    if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                        if (!$util.isInteger(message.offset) && !(message.offset && $util.isInteger(message.offset.low) && $util.isInteger(message.offset.high)))\n                            return \"offset: integer|Long expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for HistoryResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.HistoryResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                HistoryResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.HistoryResult\";\n                };\n\n                return HistoryResult;\n            })();\n\n            protocol.PingRequest = (function() {\n\n                /**\n                 * Properties of a PingRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPingRequest\n                 */\n\n                /**\n                 * Constructs a new PingRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a PingRequest.\n                 * @implements IPingRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPingRequest=} [properties] Properties to set\n                 */\n                function PingRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Encodes the specified PingRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.PingRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.PingRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPingRequest} message PingRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PingRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified PingRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.PingRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PingRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPingRequest} message PingRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PingRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a PingRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.PingRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.PingRequest} PingRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PingRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.PingRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a PingRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PingRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.PingRequest} PingRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PingRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a PingRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.PingRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PingRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for PingRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.PingRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                PingRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.PingRequest\";\n                };\n\n                return PingRequest;\n            })();\n\n            protocol.PingResult = (function() {\n\n                /**\n                 * Properties of a PingResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IPingResult\n                 */\n\n                /**\n                 * Constructs a new PingResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a PingResult.\n                 * @implements IPingResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IPingResult=} [properties] Properties to set\n                 */\n                function PingResult(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * Encodes the specified PingResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.PingResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.PingResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPingResult} message PingResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PingResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified PingResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.PingResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PingResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IPingResult} message PingResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PingResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a PingResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.PingResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.PingResult} PingResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PingResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.PingResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a PingResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.PingResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.PingResult} PingResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PingResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a PingResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.PingResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PingResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for PingResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.PingResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                PingResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.PingResult\";\n                };\n\n                return PingResult;\n            })();\n\n            protocol.RPCRequest = (function() {\n\n                /**\n                 * Properties of a RPCRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IRPCRequest\n                 * @property {Uint8Array|null} [data] RPCRequest data\n                 * @property {string|null} [method] RPCRequest method\n                 */\n\n                /**\n                 * Constructs a new RPCRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a RPCRequest.\n                 * @implements IRPCRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IRPCRequest=} [properties] Properties to set\n                 */\n                function RPCRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * RPCRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.RPCRequest\n                 * @instance\n                 */\n                RPCRequest.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * RPCRequest method.\n                 * @member {string} method\n                 * @memberof centrifugal.centrifuge.protocol.RPCRequest\n                 * @instance\n                 */\n                RPCRequest.prototype.method = \"\";\n\n                /**\n                 * Encodes the specified RPCRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.RPCRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.RPCRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRPCRequest} message RPCRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                RPCRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    if (message.method != null && Object.hasOwnProperty.call(message, \"method\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.method);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified RPCRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.RPCRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.RPCRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRPCRequest} message RPCRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                RPCRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a RPCRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.RPCRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.RPCRequest} RPCRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                RPCRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.RPCRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        case 2: {\n                                message.method = reader.string();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a RPCRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.RPCRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.RPCRequest} RPCRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                RPCRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a RPCRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.RPCRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                RPCRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    if (message.method != null && message.hasOwnProperty(\"method\"))\n                        if (!$util.isString(message.method))\n                            return \"method: string expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for RPCRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.RPCRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                RPCRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.RPCRequest\";\n                };\n\n                return RPCRequest;\n            })();\n\n            protocol.RPCResult = (function() {\n\n                /**\n                 * Properties of a RPCResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IRPCResult\n                 * @property {Uint8Array|null} [data] RPCResult data\n                 */\n\n                /**\n                 * Constructs a new RPCResult.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a RPCResult.\n                 * @implements IRPCResult\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IRPCResult=} [properties] Properties to set\n                 */\n                function RPCResult(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * RPCResult data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.RPCResult\n                 * @instance\n                 */\n                RPCResult.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * Encodes the specified RPCResult message. Does not implicitly {@link centrifugal.centrifuge.protocol.RPCResult.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.RPCResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRPCResult} message RPCResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                RPCResult.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified RPCResult message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.RPCResult.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.RPCResult\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IRPCResult} message RPCResult message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                RPCResult.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a RPCResult message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.RPCResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.RPCResult} RPCResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                RPCResult.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.RPCResult();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a RPCResult message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.RPCResult\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.RPCResult} RPCResult\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                RPCResult.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a RPCResult message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.RPCResult\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                RPCResult.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for RPCResult\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.RPCResult\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                RPCResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.RPCResult\";\n                };\n\n                return RPCResult;\n            })();\n\n            protocol.SendRequest = (function() {\n\n                /**\n                 * Properties of a SendRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface ISendRequest\n                 * @property {Uint8Array|null} [data] SendRequest data\n                 */\n\n                /**\n                 * Constructs a new SendRequest.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a SendRequest.\n                 * @implements ISendRequest\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.ISendRequest=} [properties] Properties to set\n                 */\n                function SendRequest(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * SendRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof centrifugal.centrifuge.protocol.SendRequest\n                 * @instance\n                 */\n                SendRequest.prototype.data = $util.newBuffer([]);\n\n                /**\n                 * Encodes the specified SendRequest message. Does not implicitly {@link centrifugal.centrifuge.protocol.SendRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.SendRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISendRequest} message SendRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SendRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified SendRequest message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.SendRequest.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SendRequest\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.ISendRequest} message SendRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SendRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a SendRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.SendRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.SendRequest} SendRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SendRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.SendRequest();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.data = reader.bytes();\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a SendRequest message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.SendRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.SendRequest} SendRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SendRequest.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a SendRequest message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.SendRequest\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                SendRequest.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.data != null && message.hasOwnProperty(\"data\"))\n                        if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data)))\n                            return \"data: buffer expected\";\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for SendRequest\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.SendRequest\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                SendRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.SendRequest\";\n                };\n\n                return SendRequest;\n            })();\n\n            protocol.FilterNode = (function() {\n\n                /**\n                 * Properties of a FilterNode.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @interface IFilterNode\n                 * @property {string|null} [op] FilterNode op\n                 * @property {string|null} [key] FilterNode key\n                 * @property {string|null} [cmp] FilterNode cmp\n                 * @property {string|null} [val] FilterNode val\n                 * @property {Array.<string>|null} [vals] FilterNode vals\n                 * @property {Array.<centrifugal.centrifuge.protocol.IFilterNode>|null} [nodes] FilterNode nodes\n                 */\n\n                /**\n                 * Constructs a new FilterNode.\n                 * @memberof centrifugal.centrifuge.protocol\n                 * @classdesc Represents a FilterNode.\n                 * @implements IFilterNode\n                 * @constructor\n                 * @param {centrifugal.centrifuge.protocol.IFilterNode=} [properties] Properties to set\n                 */\n                function FilterNode(properties) {\n                    this.vals = [];\n                    this.nodes = [];\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n\n                /**\n                 * FilterNode op.\n                 * @member {string} op\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @instance\n                 */\n                FilterNode.prototype.op = \"\";\n\n                /**\n                 * FilterNode key.\n                 * @member {string} key\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @instance\n                 */\n                FilterNode.prototype.key = \"\";\n\n                /**\n                 * FilterNode cmp.\n                 * @member {string} cmp\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @instance\n                 */\n                FilterNode.prototype.cmp = \"\";\n\n                /**\n                 * FilterNode val.\n                 * @member {string} val\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @instance\n                 */\n                FilterNode.prototype.val = \"\";\n\n                /**\n                 * FilterNode vals.\n                 * @member {Array.<string>} vals\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @instance\n                 */\n                FilterNode.prototype.vals = $util.emptyArray;\n\n                /**\n                 * FilterNode nodes.\n                 * @member {Array.<centrifugal.centrifuge.protocol.IFilterNode>} nodes\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @instance\n                 */\n                FilterNode.prototype.nodes = $util.emptyArray;\n\n                /**\n                 * Encodes the specified FilterNode message. Does not implicitly {@link centrifugal.centrifuge.protocol.FilterNode.verify|verify} messages.\n                 * @function encode\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IFilterNode} message FilterNode message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FilterNode.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.op != null && Object.hasOwnProperty.call(message, \"op\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.op);\n                    if (message.key != null && Object.hasOwnProperty.call(message, \"key\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.key);\n                    if (message.cmp != null && Object.hasOwnProperty.call(message, \"cmp\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.cmp);\n                    if (message.val != null && Object.hasOwnProperty.call(message, \"val\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.val);\n                    if (message.vals != null && message.vals.length)\n                        for (let i = 0; i < message.vals.length; ++i)\n                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.vals[i]);\n                    if (message.nodes != null && message.nodes.length)\n                        for (let i = 0; i < message.nodes.length; ++i)\n                            $root.centrifugal.centrifuge.protocol.FilterNode.encode(message.nodes[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    return writer;\n                };\n\n                /**\n                 * Encodes the specified FilterNode message, length delimited. Does not implicitly {@link centrifugal.centrifuge.protocol.FilterNode.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @static\n                 * @param {centrifugal.centrifuge.protocol.IFilterNode} message FilterNode message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FilterNode.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n\n                /**\n                 * Decodes a FilterNode message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {centrifugal.centrifuge.protocol.FilterNode} FilterNode\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FilterNode.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.centrifugal.centrifuge.protocol.FilterNode();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1: {\n                                message.op = reader.string();\n                                break;\n                            }\n                        case 2: {\n                                message.key = reader.string();\n                                break;\n                            }\n                        case 3: {\n                                message.cmp = reader.string();\n                                break;\n                            }\n                        case 4: {\n                                message.val = reader.string();\n                                break;\n                            }\n                        case 5: {\n                                if (!(message.vals && message.vals.length))\n                                    message.vals = [];\n                                message.vals.push(reader.string());\n                                break;\n                            }\n                        case 6: {\n                                if (!(message.nodes && message.nodes.length))\n                                    message.nodes = [];\n                                message.nodes.push($root.centrifugal.centrifuge.protocol.FilterNode.decode(reader, reader.uint32()));\n                                break;\n                            }\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n\n                /**\n                 * Decodes a FilterNode message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {centrifugal.centrifuge.protocol.FilterNode} FilterNode\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FilterNode.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n\n                /**\n                 * Verifies a FilterNode message.\n                 * @function verify\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                FilterNode.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.op != null && message.hasOwnProperty(\"op\"))\n                        if (!$util.isString(message.op))\n                            return \"op: string expected\";\n                    if (message.key != null && message.hasOwnProperty(\"key\"))\n                        if (!$util.isString(message.key))\n                            return \"key: string expected\";\n                    if (message.cmp != null && message.hasOwnProperty(\"cmp\"))\n                        if (!$util.isString(message.cmp))\n                            return \"cmp: string expected\";\n                    if (message.val != null && message.hasOwnProperty(\"val\"))\n                        if (!$util.isString(message.val))\n                            return \"val: string expected\";\n                    if (message.vals != null && message.hasOwnProperty(\"vals\")) {\n                        if (!Array.isArray(message.vals))\n                            return \"vals: array expected\";\n                        for (let i = 0; i < message.vals.length; ++i)\n                            if (!$util.isString(message.vals[i]))\n                                return \"vals: string[] expected\";\n                    }\n                    if (message.nodes != null && message.hasOwnProperty(\"nodes\")) {\n                        if (!Array.isArray(message.nodes))\n                            return \"nodes: array expected\";\n                        for (let i = 0; i < message.nodes.length; ++i) {\n                            let error = $root.centrifugal.centrifuge.protocol.FilterNode.verify(message.nodes[i]);\n                            if (error)\n                                return \"nodes.\" + error;\n                        }\n                    }\n                    return null;\n                };\n\n                /**\n                 * Gets the default type url for FilterNode\n                 * @function getTypeUrl\n                 * @memberof centrifugal.centrifuge.protocol.FilterNode\n                 * @static\n                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                 * @returns {string} The default type url\n                 */\n                FilterNode.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                    if (typeUrlPrefix === undefined) {\n                        typeUrlPrefix = \"type.googleapis.com\";\n                    }\n                    return typeUrlPrefix + \"/centrifugal.centrifuge.protocol.FilterNode\";\n                };\n\n                return FilterNode;\n            })();\n\n            return protocol;\n        })();\n\n        return centrifuge;\n    })();\n\n    return centrifugal;\n})();\n\nexport { $root as default };\n", "/**\n * This file is the entrypoint of browser builds.\n * The code executes when loaded in a browser.\n */\nimport { Centrifuge } from './centrifuge';\nimport { ProtobufCodec } from './protobuf.codec';\n\nexport default class CentrifugeProtobuf extends Centrifuge {\n    protected _formatOverride() {\n        this._codec = new ProtobufCodec();\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).Centrifuge = CentrifugeProtobuf\n"],
  "mappings": "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",
  "names": ["require_events", "__commonJSMin", "exports", "module", "R", "ReflectApply", "target", "receiver", "args", "ReflectOwnKeys", "ProcessEmitWarning", "warning", "NumberIsNaN", "value", "EventEmitter", "once", "defaultMaxListeners", "checkListener", "listener", "arg", "n", "_getMaxListeners", "that", "type", "i", "doError", "events", "er", "err", "handler", "len", "listeners", "arrayClone", "_addListener", "prepend", "m", "existing", "w", "onceWrapper", "_onceWrap", "state", "wrapped", "list", "position", "originalListener", "spliceOne", "keys", "key", "_listeners", "unwrap", "evlistener", "unwrapListeners", "emitter", "listenerCount", "arr", "copy", "index", "ret", "name", "resolve", "reject", "errorListener", "resolver", "eventTargetAgnosticAddListener", "addErrorHandlerIfEventEmitter", "flags", "wrapListener", "require_aspromise", "__commonJSMin", "exports", "module", "asPromise", "fn", "ctx", "params", "offset", "index", "pending", "resolve", "reject", "err", "require_base64", "__commonJSMin", "exports", "base64", "string", "p", "b64", "s64", "i", "buffer", "start", "end", "parts", "chunk", "j", "t", "b", "invalidEncoding", "offset", "require_eventemitter", "__commonJSMin", "exports", "module", "EventEmitter", "evt", "fn", "ctx", "listeners", "i", "args", "require_float", "__commonJSMin", "exports", "module", "factory", "f32", "f8b", "le", "writeFloat_f32_cpy", "val", "buf", "pos", "writeFloat_f32_rev", "readFloat_f32_cpy", "readFloat_f32_rev", "writeFloat_ieee754", "writeUint", "sign", "exponent", "mantissa", "writeUintLE", "writeUintBE", "readFloat_ieee754", "readUint", "uint", "readUintLE", "readUintBE", "f64", "writeDouble_f64_cpy", "writeDouble_f64_rev", "readDouble_f64_cpy", "readDouble_f64_rev", "writeDouble_ieee754", "off0", "off1", "readDouble_ieee754", "lo", "hi", "require_inquire", "__commonJSMin", "e", "require_utf8", "__commonJSMin", "exports", "utf8", "string", "len", "c", "i", "buffer", "start", "end", "parts", "chunk", "t", "offset", "c1", "c2", "require_pool", "__commonJSMin", "exports", "module", "pool", "alloc", "slice", "size", "SIZE", "MAX", "slab", "offset", "buf", "require_longbits", "__commonJSMin", "exports", "module", "LongBits", "util", "lo", "hi", "zero", "zeroHash", "value", "sign", "unsigned", "charCodeAt", "hash", "mask", "part0", "part1", "part2", "require_minimal", "__commonJSMin", "exports", "util", "value", "obj", "prop", "Buffer", "sizeOrArray", "hash", "unsigned", "bits", "merge", "dst", "src", "ifNotSet", "keys", "i", "str", "newError", "name", "CustomError", "message", "properties", "fieldNames", "fieldMap", "encoding", "size", "require_writer", "__commonJSMin", "exports", "module", "Writer", "util", "BufferWriter", "LongBits", "base64", "utf8", "Op", "fn", "len", "val", "noop", "State", "writer", "create", "size", "writeByte", "buf", "pos", "writeVarint32", "VarintOp", "value", "writeVarint64", "bits", "writeFixed32", "writeBytes", "i", "head", "tail", "BufferWriter_", "require_writer_buffer", "__commonJSMin", "exports", "module", "BufferWriter", "Writer", "util", "val", "buf", "pos", "i", "value", "len", "writeStringBuffer", "require_reader", "__commonJSMin", "exports", "module", "Reader", "util", "BufferReader", "LongBits", "utf8", "indexOutOfRange", "reader", "writeLength", "buffer", "create_array", "create", "value", "readLongVarint", "bits", "i", "readFixed32_end", "buf", "end", "readFixed64", "length", "start", "nativeBuffer", "bytes", "wireType", "BufferReader_", "fn", "require_reader_buffer", "__commonJSMin", "exports", "module", "BufferReader", "Reader", "util", "buffer", "len", "require_service", "__commonJSMin", "exports", "module", "Service", "util", "rpcImpl", "requestDelimited", "responseDelimited", "rpcCall", "method", "requestCtor", "responseCtor", "request", "callback", "self", "err", "response", "endedByRPC", "require_rpc", "__commonJSMin", "exports", "rpc", "require_roots", "__commonJSMin", "exports", "module", "require_index_minimal", "__commonJSMin", "exports", "protobuf", "configure", "require_minimal", "__commonJSMin", "exports", "module", "import_events", "State", "SubscriptionState", "startsWith", "value", "prefix", "isFunction", "log", "level", "args", "logger", "randomInt", "min", "max", "backoff", "step", "interval", "errorExists", "data", "ttlMilliseconds", "ttl", "Subscription", "EventEmitter", "centrifuge", "channel", "options", "ctx", "timeout", "res", "rej", "data", "opts", "tagsFilter", "resolve", "reject", "timeoutDuration", "newState", "oldState", "result", "pubs", "i", "ttlMilliseconds", "code", "reason", "token", "e", "error", "UnauthorizedError", "cmd", "resolveCtx", "rejectCtx", "req", "offset", "epoch", "args", "sendUnsubscribe", "promise", "pub", "newData", "newPrevValue", "join", "info", "leave", "id", "err", "self", "delay", "errContext", "backoff", "getToken", "msg", "SockjsTransport", "endpoint", "options", "_protocol", "callbacks", "e", "closeEvent", "event", "data", "WebsocketTransport", "endpoint", "options", "protocol", "callbacks", "subProtocol", "e", "closeEvent", "event", "data", "HttpStreamTransport", "endpoint", "options", "response", "self", "eventTarget", "fetchFunc", "jsonStreamBuf", "jsonStreamPos", "protoStreamBuf", "reader", "controller", "pump", "done", "value", "line", "mergedArray", "result", "data", "error", "e", "protocol", "callbacks", "initialData", "headers", "body", "fetchOptions", "session", "node", "req", "SseTransport", "endpoint", "options", "_protocol", "callbacks", "initialData", "url", "eventsourceOptions", "eventSource", "self", "e", "data", "session", "node", "req", "headers", "body", "fetchFunc", "fetchOptions", "WebtransportTransport", "endpoint", "options", "protocol", "callbacks", "url", "eventTarget", "stream", "reader", "jsonStreamBuf", "jsonStreamPos", "protoStreamBuf", "done", "value", "line", "mergedArray", "result", "data", "binary", "zValue", "Reader", "array", "b", "v", "c", "Writer", "sourceType", "a", "start", "end", "i", "checksum", "arr", "sum0", "sum1", "sum2", "sum3", "z", "N", "applyDelta", "source", "delta", "total", "zDelta", "lenSrc", "lenDelta", "limit", "zOut", "cnt", "ofst", "out", "JsonCodec", "commands", "c", "data", "r", "pub", "prevValue", "newData", "newPrevValue", "valueArray", "applyDelta", "import_events", "defaults", "UnauthorizedError", "message", "Centrifuge", "EventEmitter", "endpoint", "options", "JsonCodec", "ctx", "channel", "sub", "Subscription", "timeout", "resolve", "reject", "token", "data", "headers", "cmd", "method", "reply", "result", "publications", "i", "clients", "clientId", "rawClient", "connInfo", "chanInfo", "self", "args", "log", "transportConfig", "transportName", "newState", "oldState", "eventTarget", "delay", "backoff", "id", "callbacks", "errback", "commands", "command", "e", "websocket", "sockjs", "eventsource", "fetchFunc", "readableStream", "count", "transportEndpoint", "WebsocketTransport", "WebtransportTransport", "HttpStreamTransport", "SseTransport", "SockjsTransport", "startsWith", "transport", "transportId", "wasOpen", "initialCommands", "connectCommand", "initialData", "connectTimeout", "closeEvent", "reason", "needReconnect", "code", "advice", "skipSending", "resolveCtx", "rejectCtx", "emptyToken", "err", "isInitialHandshake", "req", "subs", "hasSubs", "res", "rej", "resultCB", "replies", "finishDispatch", "p", "next", "reconnect", "previousState", "needEvent", "ttlMilliseconds", "_", "ch", "subCtx", "pubs", "epoch", "offset", "errorExists", "error", "callback", "join", "leave", "unsubscribe", "disconnect", "pub", "clientInfo", "info", "temporary", "errObject", "isFunction", "SubscriptionState", "State", "import_minimal", "$protobuf", "$Reader", "$Writer", "$util", "$root", "centrifugal", "centrifuge", "protocol", "Error", "properties", "keys", "i", "message", "writer", "reader", "length", "end", "tag", "typeUrlPrefix", "EmulationRequest", "Command", "error", "Reply", "Push", "ClientInfo", "Publication", "key", "value", "end2", "tag2", "Join", "Leave", "Unsubscribe", "Subscribe", "Message", "Connect", "Disconnect", "Refresh", "ConnectRequest", "ConnectResult", "RefreshRequest", "RefreshResult", "SubscribeRequest", "SubscribeResult", "SubRefreshRequest", "SubRefreshResult", "UnsubscribeRequest", "UnsubscribeResult", "PublishRequest", "PublishResult", "PresenceRequest", "PresenceResult", "PresenceStatsRequest", "PresenceStatsResult", "StreamPosition", "HistoryRequest", "HistoryResult", "PingRequest", "PingResult", "RPCRequest", "RPCResult", "SendRequest", "FilterNode", "Command", "centrifugal", "Reply", "EmulationRequest", "ProtobufCodec", "req", "writer", "commands", "command", "replies", "reply", "data", "reader", "pub", "prevValue", "newData", "newPrevValue", "valueArray", "applyDelta", "CentrifugeProtobuf", "Centrifuge", "ProtobufCodec"]
}
